<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_junjfpk3lk1m-2{list-style-type:none}ul.lst-kix_junjfpk3lk1m-1{list-style-type:none}ul.lst-kix_junjfpk3lk1m-4{list-style-type:none}ul.lst-kix_junjfpk3lk1m-3{list-style-type:none}ul.lst-kix_junjfpk3lk1m-0{list-style-type:none}ul.lst-kix_junjfpk3lk1m-6{list-style-type:none}ul.lst-kix_junjfpk3lk1m-5{list-style-type:none}.lst-kix_hegj95gd5bm4-3>li:before{content:"-  "}ul.lst-kix_junjfpk3lk1m-8{list-style-type:none}ul.lst-kix_junjfpk3lk1m-7{list-style-type:none}.lst-kix_hegj95gd5bm4-4>li:before{content:"-  "}.lst-kix_hegj95gd5bm4-5>li:before{content:"-  "}.lst-kix_hegj95gd5bm4-6>li:before{content:"-  "}.lst-kix_hegj95gd5bm4-8>li:before{content:"-  "}ol.lst-kix_7aani3dcd0w3-4.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-4 0}.lst-kix_hegj95gd5bm4-7>li:before{content:"-  "}ol.lst-kix_enlqsq9z2ad9-3.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-3 0}.lst-kix_ghlevs8g51r9-0>li:before{content:"\0025cf  "}.lst-kix_ghlevs8g51r9-1>li:before{content:"\0025cb  "}ul.lst-kix_yqe02awvv2ik-1{list-style-type:none}ul.lst-kix_yqe02awvv2ik-0{list-style-type:none}ul.lst-kix_m7pghtu66va-3{list-style-type:none}.lst-kix_7aani3dcd0w3-5>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-5}ul.lst-kix_yqe02awvv2ik-3{list-style-type:none}ul.lst-kix_m7pghtu66va-2{list-style-type:none}.lst-kix_ghlevs8g51r9-7>li:before{content:"\0025cb  "}ul.lst-kix_yqe02awvv2ik-2{list-style-type:none}ul.lst-kix_m7pghtu66va-5{list-style-type:none}ul.lst-kix_yqe02awvv2ik-5{list-style-type:none}ul.lst-kix_m7pghtu66va-4{list-style-type:none}ul.lst-kix_yqe02awvv2ik-4{list-style-type:none}ul.lst-kix_yqe02awvv2ik-7{list-style-type:none}.lst-kix_ghlevs8g51r9-8>li:before{content:"\0025a0  "}ul.lst-kix_yqe02awvv2ik-6{list-style-type:none}ul.lst-kix_m7pghtu66va-1{list-style-type:none}ul.lst-kix_m7pghtu66va-0{list-style-type:none}ul.lst-kix_yqe02awvv2ik-8{list-style-type:none}.lst-kix_j7pwumu6gnqz-6>li:before{content:"\0025cf  "}.lst-kix_j7pwumu6gnqz-7>li:before{content:"\0025cb  "}.lst-kix_efftnt5a2xc6-5>li:before{content:"\0025a0  "}.lst-kix_j7pwumu6gnqz-2>li:before{content:"\0025a0  "}.lst-kix_efftnt5a2xc6-3>li:before{content:"\0025cf  "}.lst-kix_efftnt5a2xc6-4>li:before{content:"\0025cb  "}.lst-kix_j7pwumu6gnqz-0>li:before{content:"\0025cf  "}.lst-kix_j7pwumu6gnqz-1>li:before{content:"\0025cb  "}.lst-kix_j7pwumu6gnqz-8>li:before{content:"\0025a0  "}.lst-kix_ghlevs8g51r9-6>li:before{content:"\0025cf  "}.lst-kix_ghlevs8g51r9-4>li:before{content:"\0025cb  "}.lst-kix_ghlevs8g51r9-5>li:before{content:"\0025a0  "}.lst-kix_hegj95gd5bm4-2>li:before{content:"-  "}.lst-kix_ghlevs8g51r9-2>li:before{content:"\0025a0  "}.lst-kix_ghlevs8g51r9-3>li:before{content:"\0025cf  "}.lst-kix_hegj95gd5bm4-0>li:before{content:"-  "}.lst-kix_hegj95gd5bm4-1>li:before{content:"-  "}.lst-kix_efftnt5a2xc6-6>li:before{content:"\0025cf  "}.lst-kix_j7pwumu6gnqz-3>li:before{content:"\0025cf  "}.lst-kix_efftnt5a2xc6-7>li:before{content:"\0025cb  "}.lst-kix_efftnt5a2xc6-8>li:before{content:"\0025a0  "}.lst-kix_j7pwumu6gnqz-4>li:before{content:"\0025cb  "}.lst-kix_j7pwumu6gnqz-5>li:before{content:"\0025a0  "}.lst-kix_7aani3dcd0w3-7>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-7,lower-latin) ". "}.lst-kix_7aani3dcd0w3-6>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-6,decimal) ". "}.lst-kix_b4zwlds6f31w-8>li:before{content:"\0025a0  "}.lst-kix_7aani3dcd0w3-2>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-2,lower-roman) ". "}.lst-kix_7aani3dcd0w3-4>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-4,lower-latin) ". "}.lst-kix_lozxriuee1k8-0>li:before{content:"\0025cf  "}.lst-kix_enlqsq9z2ad9-8>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-8,lower-roman) ". "}.lst-kix_b4zwlds6f31w-2>li:before{content:"\0025a0  "}.lst-kix_efftnt5a2xc6-2>li:before{content:"\0025a0  "}.lst-kix_7aani3dcd0w3-0>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-0,decimal) ". "}.lst-kix_6w9khmgz918g-0>li:before{content:"\0025cf  "}.lst-kix_6w9khmgz918g-2>li:before{content:"\0025a0  "}.lst-kix_b4zwlds6f31w-4>li:before{content:"\0025cb  "}.lst-kix_6w9khmgz918g-4>li:before{content:"\0025cb  "}.lst-kix_efftnt5a2xc6-0>li:before{content:"\0025cf  "}.lst-kix_b4zwlds6f31w-6>li:before{content:"\0025cf  "}.lst-kix_6w9khmgz918g-8>li:before{content:"\0025a0  "}.lst-kix_lozxriuee1k8-6>li:before{content:"\0025cf  "}.lst-kix_6w9khmgz918g-6>li:before{content:"\0025cf  "}.lst-kix_enlqsq9z2ad9-0>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-0,decimal) ". "}.lst-kix_q4pfpg5v40ry-8>li:before{content:"\0025a0  "}.lst-kix_lozxriuee1k8-8>li:before{content:"\0025a0  "}ul.lst-kix_jmpizlww91eb-8{list-style-type:none}.lst-kix_enlqsq9z2ad9-2>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-2,lower-roman) ". "}ul.lst-kix_jmpizlww91eb-7{list-style-type:none}ul.lst-kix_jmpizlww91eb-6{list-style-type:none}.lst-kix_lozxriuee1k8-2>li:before{content:"\0025a0  "}ul.lst-kix_jmpizlww91eb-1{list-style-type:none}ul.lst-kix_jmpizlww91eb-0{list-style-type:none}.lst-kix_enlqsq9z2ad9-6>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-6,decimal) ". "}ul.lst-kix_jmpizlww91eb-5{list-style-type:none}ul.lst-kix_jmpizlww91eb-4{list-style-type:none}.lst-kix_enlqsq9z2ad9-4>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-4,lower-latin) ". "}ul.lst-kix_8vi5oc8p4pg0-8{list-style-type:none}ul.lst-kix_jmpizlww91eb-3{list-style-type:none}ul.lst-kix_8vi5oc8p4pg0-7{list-style-type:none}ul.lst-kix_jmpizlww91eb-2{list-style-type:none}.lst-kix_enlqsq9z2ad9-2>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-2}ul.lst-kix_8vi5oc8p4pg0-6{list-style-type:none}.lst-kix_lozxriuee1k8-4>li:before{content:"\0025cb  "}ul.lst-kix_8vi5oc8p4pg0-5{list-style-type:none}ul.lst-kix_8vi5oc8p4pg0-4{list-style-type:none}ul.lst-kix_8vi5oc8p4pg0-3{list-style-type:none}ul.lst-kix_8vi5oc8p4pg0-2{list-style-type:none}ul.lst-kix_8vi5oc8p4pg0-1{list-style-type:none}ul.lst-kix_8vi5oc8p4pg0-0{list-style-type:none}.lst-kix_9r9qns1l7tou-1>li:before{content:"\0025cb  "}.lst-kix_9r9qns1l7tou-5>li:before{content:"\0025a0  "}.lst-kix_q4pfpg5v40ry-2>li:before{content:"\0025a0  "}.lst-kix_q4pfpg5v40ry-0>li:before{content:"\0025cf  "}.lst-kix_9r9qns1l7tou-3>li:before{content:"\0025cf  "}.lst-kix_q4pfpg5v40ry-6>li:before{content:"\0025cf  "}.lst-kix_q4pfpg5v40ry-4>li:before{content:"\0025cb  "}.lst-kix_9r9qns1l7tou-7>li:before{content:"\0025cb  "}ul.lst-kix_54rh6a6ewprb-6{list-style-type:none}ul.lst-kix_54rh6a6ewprb-5{list-style-type:none}ul.lst-kix_54rh6a6ewprb-8{list-style-type:none}.lst-kix_htaxbahyi9ac-0>li:before{content:"\0025cf  "}ul.lst-kix_54rh6a6ewprb-7{list-style-type:none}ul.lst-kix_54rh6a6ewprb-2{list-style-type:none}ul.lst-kix_54rh6a6ewprb-1{list-style-type:none}ul.lst-kix_54rh6a6ewprb-4{list-style-type:none}ul.lst-kix_54rh6a6ewprb-3{list-style-type:none}ul.lst-kix_54rh6a6ewprb-0{list-style-type:none}.lst-kix_htaxbahyi9ac-2>li:before{content:"\0025a0  "}.lst-kix_enlqsq9z2ad9-3>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-3}.lst-kix_b4zwlds6f31w-0>li:before{content:"\0025cf  "}.lst-kix_k5sh93b5y13o-0>li:before{content:"\0025cf  "}.lst-kix_k5sh93b5y13o-4>li:before{content:"\0025cb  "}.lst-kix_k5sh93b5y13o-3>li:before{content:"\0025cf  "}.lst-kix_htaxbahyi9ac-8>li:before{content:"\0025a0  "}.lst-kix_gpuswq30cw3b-2>li:before{content:"\0025a0  "}.lst-kix_htaxbahyi9ac-4>li:before{content:"\0025cb  "}.lst-kix_gpuswq30cw3b-6>li:before{content:"\0025cf  "}.lst-kix_htaxbahyi9ac-5>li:before{content:"\0025a0  "}.lst-kix_gpuswq30cw3b-5>li:before{content:"\0025a0  "}.lst-kix_px80xspa50tp-6>li:before{content:"\0025cf  "}.lst-kix_px80xspa50tp-7>li:before{content:"\0025cb  "}.lst-kix_gpuswq30cw3b-1>li:before{content:"\0025cb  "}.lst-kix_k5sh93b5y13o-8>li:before{content:"\0025a0  "}.lst-kix_k5sh93b5y13o-7>li:before{content:"\0025cb  "}.lst-kix_px80xspa50tp-2>li:before{content:"\0025a0  "}.lst-kix_px80xspa50tp-3>li:before{content:"\0025cf  "}ul.lst-kix_px80xspa50tp-5{list-style-type:none}ul.lst-kix_9r9qns1l7tou-1{list-style-type:none}ul.lst-kix_px80xspa50tp-4{list-style-type:none}ul.lst-kix_9r9qns1l7tou-2{list-style-type:none}ul.lst-kix_px80xspa50tp-3{list-style-type:none}ul.lst-kix_9r9qns1l7tou-3{list-style-type:none}ul.lst-kix_px80xspa50tp-2{list-style-type:none}ul.lst-kix_9r9qns1l7tou-4{list-style-type:none}ul.lst-kix_px80xspa50tp-1{list-style-type:none}ul.lst-kix_px80xspa50tp-0{list-style-type:none}.lst-kix_8vndm4gbn4ci-3>li:before{content:"\0025cf  "}.lst-kix_8vndm4gbn4ci-4>li:before{content:"\0025cb  "}.lst-kix_8vndm4gbn4ci-7>li:before{content:"\0025cb  "}.lst-kix_8vndm4gbn4ci-8>li:before{content:"\0025a0  "}ul.lst-kix_9r9qns1l7tou-0{list-style-type:none}ul.lst-kix_9r9qns1l7tou-5{list-style-type:none}ul.lst-kix_px80xspa50tp-8{list-style-type:none}ul.lst-kix_9r9qns1l7tou-6{list-style-type:none}ul.lst-kix_px80xspa50tp-7{list-style-type:none}ul.lst-kix_9r9qns1l7tou-7{list-style-type:none}ul.lst-kix_px80xspa50tp-6{list-style-type:none}ul.lst-kix_9r9qns1l7tou-8{list-style-type:none}.lst-kix_8vndm4gbn4ci-0>li:before{content:"\0025cf  "}ul.lst-kix_g58d2ggy4gc1-8{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-7{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-6{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-5{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-4{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-3{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-2{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-1{list-style-type:none}ul.lst-kix_g58d2ggy4gc1-0{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-7{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-8{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-5{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-6{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-0{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-3{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-4{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-1{list-style-type:none}ul.lst-kix_ds3uygkxmu1a-2{list-style-type:none}.lst-kix_7aani3dcd0w3-8>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-8,lower-roman) ". "}.lst-kix_7aani3dcd0w3-5>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-5,lower-roman) ". "}.lst-kix_b4zwlds6f31w-7>li:before{content:"\0025cb  "}.lst-kix_efftnt5a2xc6-1>li:before{content:"\0025cb  "}.lst-kix_i3c8vb9n7x7o-1>li:before{content:"\0025cb  "}.lst-kix_7aani3dcd0w3-1>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-1,lower-latin) ". "}.lst-kix_b4zwlds6f31w-3>li:before{content:"\0025cf  "}.lst-kix_6w9khmgz918g-3>li:before{content:"\0025cf  "}.lst-kix_8ian3glbwk9e-5>li:before{content:"\0025a0  "}.lst-kix_i3c8vb9n7x7o-5>li:before{content:"\0025a0  "}.lst-kix_6w9khmgz918g-7>li:before{content:"\0025cb  "}.lst-kix_enlqsq9z2ad9-1>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-1,lower-latin) ". "}.lst-kix_6x0rcrvd8q7c-4>li:before{content:"\0025cb  "}.lst-kix_8ian3glbwk9e-1>li:before{content:"\0025cb  "}.lst-kix_lozxriuee1k8-1>li:before{content:"\0025cb  "}.lst-kix_lozxriuee1k8-5>li:before{content:"\0025a0  "}.lst-kix_6x0rcrvd8q7c-0>li:before{content:"\0025cf  "}.lst-kix_enlqsq9z2ad9-5>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-5,lower-roman) ". "}.lst-kix_je8f38j0gr98-6>li:before{content:"\0025cf  "}.lst-kix_9r9qns1l7tou-2>li:before{content:"\0025a0  "}.lst-kix_k7md3c5ksz8x-3>li:before{content:"\0025cf  "}.lst-kix_o9kmpjmc1djl-4>li:before{content:"\0025cb  "}.lst-kix_q4pfpg5v40ry-1>li:before{content:"\0025cb  "}.lst-kix_o9kmpjmc1djl-8>li:before{content:"\0025a0  "}.lst-kix_q4pfpg5v40ry-5>li:before{content:"\0025a0  "}.lst-kix_k7md3c5ksz8x-7>li:before{content:"\0025cb  "}.lst-kix_uox1zzti676w-4>li:before{content:"\0025cb  "}.lst-kix_je8f38j0gr98-2>li:before{content:"\0025a0  "}.lst-kix_jmpizlww91eb-7>li:before{content:"\0025cb  "}.lst-kix_1uiq9wd1knsy-6>li:before{content:"\0025cf  "}.lst-kix_9r9qns1l7tou-6>li:before{content:"\0025cf  "}.lst-kix_6x0rcrvd8q7c-8>li:before{content:"\0025a0  "}.lst-kix_uox1zzti676w-0>li:before{content:"\0025cf  "}.lst-kix_54rh6a6ewprb-5>li:before{content:"\0025a0  "}.lst-kix_jmpizlww91eb-3>li:before{content:"\0025cf  "}.lst-kix_54rh6a6ewprb-1>li:before{content:"\0025cb  "}.lst-kix_1uiq9wd1knsy-2>li:before{content:"\0025a0  "}.lst-kix_htaxbahyi9ac-1>li:before{content:"\0025cb  "}.lst-kix_7aani3dcd0w3-3>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-3}.lst-kix_o9kmpjmc1djl-0>li:before{content:"\0025cf  "}.lst-kix_1vd5g4tj2m3r-8>li:before{content:"\0025a0  "}.lst-kix_7x9dfnwo95qd-2>li:before{content:"\0025a0  "}.lst-kix_7x9dfnwo95qd-5>li:before{content:"\0025a0  "}.lst-kix_g58d2ggy4gc1-1>li:before{content:"\0025cb  "}.lst-kix_junjfpk3lk1m-6>li:before{content:"\0025cf  "}.lst-kix_junjfpk3lk1m-8>li:before{content:"\0025a0  "}.lst-kix_1vd5g4tj2m3r-6>li:before{content:"\0025cf  "}.lst-kix_3n4k5copjjhj-0>li:before{content:"\0025cf  "}.lst-kix_7x9dfnwo95qd-7>li:before{content:"\0025cb  "}.lst-kix_7x9dfnwo95qd-4>li:before{content:"\0025cb  "}ul.lst-kix_6y1ttbq1ogav-8{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-3{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-2{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-1{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-0{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-7{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-6{list-style-type:none}.lst-kix_uox1zzti676w-7>li:before{content:"\0025cb  "}ul.lst-kix_6y1ttbq1ogav-5{list-style-type:none}ul.lst-kix_6y1ttbq1ogav-4{list-style-type:none}.lst-kix_g58d2ggy4gc1-6>li:before{content:"\0025cf  "}.lst-kix_uox1zzti676w-8>li:before{content:"\0025a0  "}.lst-kix_1vd5g4tj2m3r-0>li:before{content:"\0025cf  "}.lst-kix_1vd5g4tj2m3r-1>li:before{content:"\0025cb  "}.lst-kix_g58d2ggy4gc1-7>li:before{content:"\0025cb  "}.lst-kix_g58d2ggy4gc1-4>li:before{content:"\0025cb  "}.lst-kix_1vd5g4tj2m3r-3>li:before{content:"\0025cf  "}ol.lst-kix_enlqsq9z2ad9-4.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-4 0}.lst-kix_3n4k5copjjhj-7>li:before{content:"\0025cb  "}.lst-kix_junjfpk3lk1m-0>li:before{content:"\0025cf  "}.lst-kix_3n4k5copjjhj-8>li:before{content:"\0025a0  "}.lst-kix_junjfpk3lk1m-3>li:before{content:"\0025cf  "}.lst-kix_3n4k5copjjhj-5>li:before{content:"\0025a0  "}.lst-kix_junjfpk3lk1m-1>li:before{content:"\0025cb  "}.lst-kix_3n4k5copjjhj-2>li:before{content:"\0025a0  "}ol.lst-kix_7aani3dcd0w3-8.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-8 0}.lst-kix_ngi8s7ju6o3u-5>li:before{content:"\0025a0  "}ol.lst-kix_enlqsq9z2ad9-2.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-2 0}.lst-kix_8vi5oc8p4pg0-5>li:before{content:"\0025a0  "}ul.lst-kix_caf22lmip6rs-0{list-style-type:none}.lst-kix_8vi5oc8p4pg0-3>li:before{content:"\0025cf  "}ul.lst-kix_caf22lmip6rs-1{list-style-type:none}ul.lst-kix_caf22lmip6rs-2{list-style-type:none}ul.lst-kix_caf22lmip6rs-3{list-style-type:none}ul.lst-kix_caf22lmip6rs-4{list-style-type:none}ul.lst-kix_caf22lmip6rs-5{list-style-type:none}ul.lst-kix_caf22lmip6rs-6{list-style-type:none}.lst-kix_i3c8vb9n7x7o-0>li:before{content:"\0025cf  "}.lst-kix_ngi8s7ju6o3u-7>li:before{content:"\0025cb  "}ul.lst-kix_caf22lmip6rs-7{list-style-type:none}ul.lst-kix_caf22lmip6rs-8{list-style-type:none}.lst-kix_o5qrq9ipmu9v-7>li:before{content:"\0025cb  "}.lst-kix_i3c8vb9n7x7o-6>li:before{content:"\0025cf  "}.lst-kix_8ian3glbwk9e-4>li:before{content:"\0025cb  "}.lst-kix_7aani3dcd0w3-7>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-7}.lst-kix_6x0rcrvd8q7c-3>li:before{content:"\0025cf  "}.lst-kix_8ian3glbwk9e-2>li:before{content:"\0025a0  "}.lst-kix_6x0rcrvd8q7c-1>li:before{content:"\0025cb  "}.lst-kix_o5qrq9ipmu9v-5>li:before{content:"\0025a0  "}.lst-kix_i3c8vb9n7x7o-8>li:before{content:"\0025a0  "}.lst-kix_k7md3c5ksz8x-0>li:before{content:"\0025cf  "}ul.lst-kix_6w9khmgz918g-0{list-style-type:none}.lst-kix_je8f38j0gr98-5>li:before{content:"\0025a0  "}ul.lst-kix_6w9khmgz918g-2{list-style-type:none}.lst-kix_1ls56psqdc4w-2>li:before{content:"\0025a0  "}ul.lst-kix_6w9khmgz918g-1{list-style-type:none}ul.lst-kix_fxxo4x7dhkhu-7{list-style-type:none}ul.lst-kix_efftnt5a2xc6-8{list-style-type:none}ul.lst-kix_6w9khmgz918g-4{list-style-type:none}.lst-kix_7aani3dcd0w3-0>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-0}ul.lst-kix_fxxo4x7dhkhu-8{list-style-type:none}ul.lst-kix_efftnt5a2xc6-7{list-style-type:none}ul.lst-kix_6w9khmgz918g-3{list-style-type:none}ul.lst-kix_6w9khmgz918g-6{list-style-type:none}ul.lst-kix_6w9khmgz918g-5{list-style-type:none}.lst-kix_k7md3c5ksz8x-2>li:before{content:"\0025a0  "}.lst-kix_o9kmpjmc1djl-5>li:before{content:"\0025a0  "}ul.lst-kix_6w9khmgz918g-8{list-style-type:none}ul.lst-kix_6w9khmgz918g-7{list-style-type:none}.lst-kix_m7pghtu66va-1>li:before{content:"\0025cb  "}.lst-kix_6y1ttbq1ogav-1>li:before{content:"\0025cb  "}.lst-kix_uox1zzti676w-5>li:before{content:"\0025a0  "}ul.lst-kix_fxxo4x7dhkhu-3{list-style-type:none}.lst-kix_1uiq9wd1knsy-7>li:before{content:"\0025cb  "}.lst-kix_6y1ttbq1ogav-3>li:before{content:"\0025cf  "}ul.lst-kix_fxxo4x7dhkhu-4{list-style-type:none}.lst-kix_je8f38j0gr98-3>li:before{content:"\0025cf  "}ul.lst-kix_fxxo4x7dhkhu-5{list-style-type:none}ul.lst-kix_fxxo4x7dhkhu-6{list-style-type:none}.lst-kix_1ls56psqdc4w-4>li:before{content:"\0025cb  "}.lst-kix_o9kmpjmc1djl-7>li:before{content:"\0025cb  "}ul.lst-kix_fxxo4x7dhkhu-0{list-style-type:none}ul.lst-kix_fxxo4x7dhkhu-1{list-style-type:none}.lst-kix_jmpizlww91eb-8>li:before{content:"\0025a0  "}ul.lst-kix_fxxo4x7dhkhu-2{list-style-type:none}.lst-kix_k7md3c5ksz8x-8>li:before{content:"\0025a0  "}ul.lst-kix_uox1zzti676w-8{list-style-type:none}ul.lst-kix_uox1zzti676w-7{list-style-type:none}.lst-kix_jmpizlww91eb-2>li:before{content:"\0025a0  "}.lst-kix_54rh6a6ewprb-8>li:before{content:"\0025a0  "}.lst-kix_yqe02awvv2ik-4>li:before{content:"\0025cb  "}.lst-kix_1zjhbx5yuacx-7>li:before{content:"\0025cb  "}.lst-kix_1uiq9wd1knsy-1>li:before{content:"\0025cb  "}.lst-kix_1zjhbx5yuacx-1>li:before{content:"\0025cb  "}.lst-kix_hh9fkajeox2u-5>li:before{content:"\0025a0  "}.lst-kix_yqe02awvv2ik-6>li:before{content:"\0025cf  "}.lst-kix_jmpizlww91eb-0>li:before{content:"\0025cf  "}ul.lst-kix_uox1zzti676w-2{list-style-type:none}ul.lst-kix_efftnt5a2xc6-4{list-style-type:none}ul.lst-kix_uox1zzti676w-1{list-style-type:none}ul.lst-kix_efftnt5a2xc6-3{list-style-type:none}ul.lst-kix_uox1zzti676w-0{list-style-type:none}ul.lst-kix_efftnt5a2xc6-6{list-style-type:none}.lst-kix_hh9fkajeox2u-3>li:before{content:"\0025cf  "}ul.lst-kix_efftnt5a2xc6-5{list-style-type:none}ul.lst-kix_uox1zzti676w-6{list-style-type:none}ul.lst-kix_efftnt5a2xc6-0{list-style-type:none}ul.lst-kix_uox1zzti676w-5{list-style-type:none}ul.lst-kix_uox1zzti676w-4{list-style-type:none}.lst-kix_54rh6a6ewprb-6>li:before{content:"\0025cf  "}ul.lst-kix_efftnt5a2xc6-2{list-style-type:none}ul.lst-kix_uox1zzti676w-3{list-style-type:none}ul.lst-kix_efftnt5a2xc6-1{list-style-type:none}.lst-kix_k5sh93b5y13o-1>li:before{content:"\0025cb  "}.lst-kix_sspruoj0x7ey-6>li:before{content:"\0025cf  "}ol.lst-kix_7aani3dcd0w3-1.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-1 0}.lst-kix_hh9fkajeox2u-0>li:before{content:"\0025cf  "}.lst-kix_sspruoj0x7ey-3>li:before{content:"\0025cf  "}.lst-kix_gpuswq30cw3b-4>li:before{content:"\0025cb  "}.lst-kix_hh9fkajeox2u-8>li:before{content:"\0025a0  "}.lst-kix_54rh6a6ewprb-0>li:before{content:"\0025cf  "}.lst-kix_htaxbahyi9ac-7>li:before{content:"\0025cb  "}.lst-kix_gpuswq30cw3b-7>li:before{content:"\0025cb  "}.lst-kix_3a3vs7gz3k6b-3>li:before{content:"\0025cf  "}.lst-kix_fxxo4x7dhkhu-6>li:before{content:"\0025cf  "}.lst-kix_g47nti3zp8ay-6>li:before{content:"\0025cf  "}.lst-kix_doe34qsvg1pd-6>li:before{content:"\0025cf  "}.lst-kix_dam61a68r3zx-8>li:before{content:"\0025a0  "}ol.lst-kix_enlqsq9z2ad9-6.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-6 0}ul.lst-kix_g47nti3zp8ay-0{list-style-type:none}.lst-kix_3a3vs7gz3k6b-0>li:before{content:"\0025cf  "}.lst-kix_caf22lmip6rs-7>li:before{content:"\0025cb  "}.lst-kix_7aani3dcd0w3-4>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-4}.lst-kix_dam61a68r3zx-5>li:before{content:"\0025a0  "}.lst-kix_px80xspa50tp-1>li:before{content:"\0025cb  "}.lst-kix_caf22lmip6rs-2>li:before{content:"\0025a0  "}.lst-kix_g47nti3zp8ay-3>li:before{content:"\0025cf  "}.lst-kix_k5sh93b5y13o-6>li:before{content:"\0025cf  "}.lst-kix_px80xspa50tp-4>li:before{content:"\0025cb  "}.lst-kix_8vndm4gbn4ci-5>li:before{content:"\0025a0  "}.lst-kix_m7pghtu66va-7>li:before{content:"\0025cb  "}ul.lst-kix_g47nti3zp8ay-8{list-style-type:none}ul.lst-kix_g47nti3zp8ay-7{list-style-type:none}ul.lst-kix_g47nti3zp8ay-6{list-style-type:none}ul.lst-kix_g47nti3zp8ay-5{list-style-type:none}ul.lst-kix_g47nti3zp8ay-4{list-style-type:none}ol.lst-kix_7aani3dcd0w3-6.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-6 0}.lst-kix_doe34qsvg1pd-1>li:before{content:"\0025cb  "}ul.lst-kix_g47nti3zp8ay-3{list-style-type:none}ul.lst-kix_g47nti3zp8ay-2{list-style-type:none}.lst-kix_dam61a68r3zx-0>li:before{content:"\0025cf  "}ul.lst-kix_g47nti3zp8ay-1{list-style-type:none}.lst-kix_8vndm4gbn4ci-2>li:before{content:"\0025a0  "}.lst-kix_9a8vxc4ia7ct-3>li:before{content:"\0025cf  "}.lst-kix_asj4vxxj20d3-2>li:before{content:"\0025a0  "}.lst-kix_fxxo4x7dhkhu-3>li:before{content:"\0025cf  "}.lst-kix_3a3vs7gz3k6b-8>li:before{content:"\0025a0  "}.lst-kix_9a8vxc4ia7ct-8>li:before{content:"\0025a0  "}ol.lst-kix_7aani3dcd0w3-7.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-7 0}.lst-kix_asj4vxxj20d3-7>li:before{content:"\0025cb  "}ol.lst-kix_enlqsq9z2ad9-5.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-5 0}ol.lst-kix_7aani3dcd0w3-0.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-0 0}.lst-kix_ngi8s7ju6o3u-2>li:before{content:"\0025a0  "}.lst-kix_8vi5oc8p4pg0-0>li:before{content:"\0025cf  "}.lst-kix_enlqsq9z2ad9-7>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-7,lower-latin) ". "}.lst-kix_6w9khmgz918g-1>li:before{content:"\0025cb  "}.lst-kix_i3c8vb9n7x7o-3>li:before{content:"\0025cf  "}ul.lst-kix_k7md3c5ksz8x-5{list-style-type:none}ol.lst-kix_7aani3dcd0w3-2.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-2 0}.lst-kix_6x0rcrvd8q7c-6>li:before{content:"\0025cf  "}ul.lst-kix_k7md3c5ksz8x-6{list-style-type:none}.lst-kix_8ian3glbwk9e-7>li:before{content:"\0025cb  "}ul.lst-kix_k7md3c5ksz8x-7{list-style-type:none}ul.lst-kix_k7md3c5ksz8x-8{list-style-type:none}.lst-kix_ds3uygkxmu1a-8>li:before{content:"\0025a0  "}ul.lst-kix_k7md3c5ksz8x-1{list-style-type:none}ul.lst-kix_k7md3c5ksz8x-2{list-style-type:none}ul.lst-kix_k7md3c5ksz8x-3{list-style-type:none}ul.lst-kix_k7md3c5ksz8x-4{list-style-type:none}.lst-kix_pflig4lw612i-3>li:before{content:"\0025cf  "}.lst-kix_9a8vxc4ia7ct-0>li:before{content:"\0025cf  "}.lst-kix_o5qrq9ipmu9v-2>li:before{content:"\0025a0  "}ol.lst-kix_7aani3dcd0w3-5.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-5 0}.lst-kix_lozxriuee1k8-3>li:before{content:"\0025cf  "}.lst-kix_ds3uygkxmu1a-0>li:before{content:"\0025cf  "}.lst-kix_8vi5oc8p4pg0-8>li:before{content:"\0025a0  "}.lst-kix_m7pghtu66va-4>li:before{content:"\0025cb  "}ul.lst-kix_k7md3c5ksz8x-0{list-style-type:none}ul.lst-kix_asj4vxxj20d3-1{list-style-type:none}ul.lst-kix_asj4vxxj20d3-0{list-style-type:none}ul.lst-kix_asj4vxxj20d3-3{list-style-type:none}.lst-kix_6y1ttbq1ogav-6>li:before{content:"\0025cf  "}ul.lst-kix_asj4vxxj20d3-2{list-style-type:none}.lst-kix_9r9qns1l7tou-4>li:before{content:"\0025cb  "}ol.lst-kix_7aani3dcd0w3-3.start{counter-reset:lst-ctn-kix_7aani3dcd0w3-3 0}.lst-kix_o9kmpjmc1djl-2>li:before{content:"\0025a0  "}.lst-kix_k7md3c5ksz8x-5>li:before{content:"\0025a0  "}.lst-kix_je8f38j0gr98-0>li:before{content:"\0025cf  "}.lst-kix_je8f38j0gr98-8>li:before{content:"\0025a0  "}ol.lst-kix_enlqsq9z2ad9-7.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-7 0}.lst-kix_1uiq9wd1knsy-4>li:before{content:"\0025cb  "}ul.lst-kix_je8f38j0gr98-0{list-style-type:none}.lst-kix_q4pfpg5v40ry-3>li:before{content:"\0025cf  "}ul.lst-kix_je8f38j0gr98-1{list-style-type:none}ul.lst-kix_je8f38j0gr98-2{list-style-type:none}.lst-kix_1ls56psqdc4w-7>li:before{content:"\0025cb  "}.lst-kix_uox1zzti676w-2>li:before{content:"\0025a0  "}.lst-kix_yqe02awvv2ik-1>li:before{content:"\0025cb  "}.lst-kix_jmpizlww91eb-5>li:before{content:"\0025a0  "}ul.lst-kix_ghlevs8g51r9-8{list-style-type:none}.lst-kix_54rh6a6ewprb-3>li:before{content:"\0025cf  "}.lst-kix_j1holzs3xttc-6>li:before{content:"\0025cf  "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_enlqsq9z2ad9-6>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-6}.lst-kix_b4zwlds6f31w-1>li:before{content:"\0025cb  "}.lst-kix_99z3queijxrv-3>li:before{content:"\0025cf  "}ol.lst-kix_enlqsq9z2ad9-8.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-8 0}ul.lst-kix_ghlevs8g51r9-7{list-style-type:none}ul.lst-kix_ghlevs8g51r9-6{list-style-type:none}ul.lst-kix_asj4vxxj20d3-8{list-style-type:none}ul.lst-kix_ghlevs8g51r9-5{list-style-type:none}.lst-kix_1zjhbx5yuacx-4>li:before{content:"\0025cb  "}ul.lst-kix_ghlevs8g51r9-4{list-style-type:none}ul.lst-kix_ghlevs8g51r9-3{list-style-type:none}ul.lst-kix_asj4vxxj20d3-5{list-style-type:none}ul.lst-kix_ghlevs8g51r9-2{list-style-type:none}ul.lst-kix_asj4vxxj20d3-4{list-style-type:none}ul.lst-kix_ghlevs8g51r9-1{list-style-type:none}ul.lst-kix_asj4vxxj20d3-7{list-style-type:none}ul.lst-kix_ghlevs8g51r9-0{list-style-type:none}ul.lst-kix_asj4vxxj20d3-6{list-style-type:none}ul.lst-kix_hh9fkajeox2u-8{list-style-type:none}ul.lst-kix_hh9fkajeox2u-7{list-style-type:none}.lst-kix_jk8gstwbu4x7-5>li:before{content:"\0025a0  "}.lst-kix_jk8gstwbu4x7-7>li:before{content:"\0025cb  "}.lst-kix_jk8gstwbu4x7-4>li:before{content:"\0025cb  "}.lst-kix_jk8gstwbu4x7-8>li:before{content:"\0025a0  "}ul.lst-kix_je8f38j0gr98-3{list-style-type:none}ul.lst-kix_je8f38j0gr98-4{list-style-type:none}ul.lst-kix_je8f38j0gr98-5{list-style-type:none}ul.lst-kix_je8f38j0gr98-6{list-style-type:none}.lst-kix_jk8gstwbu4x7-1>li:before{content:"\0025cb  "}.lst-kix_jk8gstwbu4x7-3>li:before{content:"\0025cf  "}ul.lst-kix_je8f38j0gr98-7{list-style-type:none}ul.lst-kix_je8f38j0gr98-8{list-style-type:none}.lst-kix_jk8gstwbu4x7-2>li:before{content:"\0025a0  "}ul.lst-kix_o9kmpjmc1djl-8{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-0{list-style-type:none}ul.lst-kix_hh9fkajeox2u-0{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-1{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-2{list-style-type:none}ul.lst-kix_hh9fkajeox2u-2{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-3{list-style-type:none}ul.lst-kix_hh9fkajeox2u-1{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-4{list-style-type:none}ul.lst-kix_hh9fkajeox2u-4{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-5{list-style-type:none}ul.lst-kix_hh9fkajeox2u-3{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-6{list-style-type:none}ul.lst-kix_hh9fkajeox2u-6{list-style-type:none}ul.lst-kix_o9kmpjmc1djl-7{list-style-type:none}ul.lst-kix_hh9fkajeox2u-5{list-style-type:none}.lst-kix_jk8gstwbu4x7-6>li:before{content:"\0025cf  "}.lst-kix_jk8gstwbu4x7-0>li:before{content:"\0025cf  "}ul.lst-kix_jk8gstwbu4x7-2{list-style-type:none}.lst-kix_7aani3dcd0w3-1>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-1}ul.lst-kix_jk8gstwbu4x7-1{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-0{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-6{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-5{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-4{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-3{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-8{list-style-type:none}ul.lst-kix_jk8gstwbu4x7-7{list-style-type:none}ul.lst-kix_8ian3glbwk9e-0{list-style-type:none}ol.lst-kix_7aani3dcd0w3-7{list-style-type:none}ol.lst-kix_7aani3dcd0w3-8{list-style-type:none}ol.lst-kix_7aani3dcd0w3-5{list-style-type:none}ul.lst-kix_8ian3glbwk9e-3{list-style-type:none}ol.lst-kix_7aani3dcd0w3-6{list-style-type:none}ul.lst-kix_8ian3glbwk9e-4{list-style-type:none}ol.lst-kix_7aani3dcd0w3-3{list-style-type:none}ul.lst-kix_8ian3glbwk9e-1{list-style-type:none}ol.lst-kix_7aani3dcd0w3-4{list-style-type:none}ul.lst-kix_8ian3glbwk9e-2{list-style-type:none}ol.lst-kix_7aani3dcd0w3-1{list-style-type:none}ul.lst-kix_8ian3glbwk9e-7{list-style-type:none}ol.lst-kix_7aani3dcd0w3-2{list-style-type:none}ul.lst-kix_8ian3glbwk9e-8{list-style-type:none}ul.lst-kix_8ian3glbwk9e-5{list-style-type:none}ol.lst-kix_7aani3dcd0w3-0{list-style-type:none}ul.lst-kix_8ian3glbwk9e-6{list-style-type:none}.lst-kix_pflig4lw612i-0>li:before{content:"\0025cf  "}.lst-kix_9a8vxc4ia7ct-1>li:before{content:"\0025cb  "}.lst-kix_pflig4lw612i-4>li:before{content:"\0025cb  "}.lst-kix_ds3uygkxmu1a-7>li:before{content:"\0025cb  "}.lst-kix_ds3uygkxmu1a-1>li:before{content:"\0025cb  "}.lst-kix_ds3uygkxmu1a-5>li:before{content:"\0025a0  "}.lst-kix_pflig4lw612i-2>li:before{content:"\0025a0  "}.lst-kix_ds3uygkxmu1a-3>li:before{content:"\0025cf  "}.lst-kix_99z3queijxrv-8>li:before{content:"\0025a0  "}.lst-kix_pflig4lw612i-6>li:before{content:"\0025cf  "}.lst-kix_pflig4lw612i-8>li:before{content:"\0025a0  "}ul.lst-kix_pflig4lw612i-8{list-style-type:none}ul.lst-kix_99z3queijxrv-0{list-style-type:none}ul.lst-kix_99z3queijxrv-1{list-style-type:none}ul.lst-kix_99z3queijxrv-2{list-style-type:none}ul.lst-kix_pflig4lw612i-4{list-style-type:none}ul.lst-kix_99z3queijxrv-3{list-style-type:none}ul.lst-kix_pflig4lw612i-5{list-style-type:none}ul.lst-kix_99z3queijxrv-4{list-style-type:none}ul.lst-kix_pflig4lw612i-6{list-style-type:none}ul.lst-kix_99z3queijxrv-5{list-style-type:none}ul.lst-kix_pflig4lw612i-7{list-style-type:none}ul.lst-kix_99z3queijxrv-6{list-style-type:none}ul.lst-kix_99z3queijxrv-7{list-style-type:none}ul.lst-kix_99z3queijxrv-8{list-style-type:none}.lst-kix_j1holzs3xttc-7>li:before{content:"\0025cb  "}.lst-kix_99z3queijxrv-0>li:before{content:"\0025cf  "}.lst-kix_j1holzs3xttc-5>li:before{content:"\0025a0  "}.lst-kix_99z3queijxrv-2>li:before{content:"\0025a0  "}.lst-kix_99z3queijxrv-6>li:before{content:"\0025cf  "}.lst-kix_j1holzs3xttc-1>li:before{content:"\0025cb  "}.lst-kix_j1holzs3xttc-3>li:before{content:"\0025cf  "}.lst-kix_99z3queijxrv-4>li:before{content:"\0025cb  "}.lst-kix_sspruoj0x7ey-4>li:before{content:"\0025cb  "}ul.lst-kix_1vd5g4tj2m3r-1{list-style-type:none}.lst-kix_enlqsq9z2ad9-7>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-7}ul.lst-kix_1vd5g4tj2m3r-0{list-style-type:none}ul.lst-kix_1vd5g4tj2m3r-3{list-style-type:none}ul.lst-kix_1vd5g4tj2m3r-2{list-style-type:none}ul.lst-kix_1vd5g4tj2m3r-5{list-style-type:none}.lst-kix_sspruoj0x7ey-1>li:before{content:"\0025cb  "}.lst-kix_sspruoj0x7ey-5>li:before{content:"\0025a0  "}ul.lst-kix_1vd5g4tj2m3r-4{list-style-type:none}ul.lst-kix_1vd5g4tj2m3r-7{list-style-type:none}ul.lst-kix_1vd5g4tj2m3r-6{list-style-type:none}ul.lst-kix_1vd5g4tj2m3r-8{list-style-type:none}.lst-kix_g47nti3zp8ay-0>li:before{content:"\0025cf  "}.lst-kix_hh9fkajeox2u-6>li:before{content:"\0025cf  "}ul.lst-kix_7x9dfnwo95qd-1{list-style-type:none}.lst-kix_sspruoj0x7ey-8>li:before{content:"\0025a0  "}ul.lst-kix_7x9dfnwo95qd-0{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-1.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-1 0}ul.lst-kix_7x9dfnwo95qd-5{list-style-type:none}ul.lst-kix_7x9dfnwo95qd-4{list-style-type:none}.lst-kix_fxxo4x7dhkhu-5>li:before{content:"\0025a0  "}ul.lst-kix_7x9dfnwo95qd-3{list-style-type:none}ul.lst-kix_7x9dfnwo95qd-2{list-style-type:none}ul.lst-kix_b4zwlds6f31w-4{list-style-type:none}.lst-kix_doe34qsvg1pd-7>li:before{content:"\0025cb  "}ul.lst-kix_b4zwlds6f31w-5{list-style-type:none}ul.lst-kix_7x9dfnwo95qd-8{list-style-type:none}ul.lst-kix_b4zwlds6f31w-6{list-style-type:none}ul.lst-kix_1zjhbx5yuacx-7{list-style-type:none}ul.lst-kix_7x9dfnwo95qd-7{list-style-type:none}ul.lst-kix_b4zwlds6f31w-7{list-style-type:none}ul.lst-kix_1zjhbx5yuacx-8{list-style-type:none}ul.lst-kix_7x9dfnwo95qd-6{list-style-type:none}ul.lst-kix_b4zwlds6f31w-8{list-style-type:none}.lst-kix_3a3vs7gz3k6b-1>li:before{content:"\0025cb  "}.lst-kix_3a3vs7gz3k6b-2>li:before{content:"\0025a0  "}.lst-kix_caf22lmip6rs-8>li:before{content:"\0025a0  "}.lst-kix_doe34qsvg1pd-3>li:before{content:"\0025cf  "}ul.lst-kix_1zjhbx5yuacx-1{list-style-type:none}.lst-kix_dam61a68r3zx-7>li:before{content:"\0025cb  "}ul.lst-kix_1zjhbx5yuacx-2{list-style-type:none}.lst-kix_fxxo4x7dhkhu-8>li:before{content:"\0025a0  "}ul.lst-kix_1zjhbx5yuacx-0{list-style-type:none}ul.lst-kix_1zjhbx5yuacx-5{list-style-type:none}.lst-kix_caf22lmip6rs-5>li:before{content:"\0025a0  "}ul.lst-kix_1zjhbx5yuacx-6{list-style-type:none}.lst-kix_g47nti3zp8ay-8>li:before{content:"\0025a0  "}.lst-kix_doe34qsvg1pd-4>li:before{content:"\0025cb  "}ul.lst-kix_1zjhbx5yuacx-3{list-style-type:none}.lst-kix_dam61a68r3zx-6>li:before{content:"\0025cf  "}ul.lst-kix_1zjhbx5yuacx-4{list-style-type:none}.lst-kix_g47nti3zp8ay-1>li:before{content:"\0025cb  "}.lst-kix_caf22lmip6rs-0>li:before{content:"\0025cf  "}.lst-kix_caf22lmip6rs-4>li:before{content:"\0025cb  "}.lst-kix_g47nti3zp8ay-5>li:before{content:"\0025a0  "}.lst-kix_sspruoj0x7ey-0>li:before{content:"\0025cf  "}.lst-kix_enlqsq9z2ad9-5>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-5}.lst-kix_caf22lmip6rs-1>li:before{content:"\0025cb  "}.lst-kix_g47nti3zp8ay-4>li:before{content:"\0025cb  "}.lst-kix_doe34qsvg1pd-8>li:before{content:"\0025a0  "}ol.lst-kix_enlqsq9z2ad9-0.start{counter-reset:lst-ctn-kix_enlqsq9z2ad9-0 0}.lst-kix_dam61a68r3zx-3>li:before{content:"\0025cf  "}.lst-kix_asj4vxxj20d3-8>li:before{content:"\0025a0  "}ul.lst-kix_b4zwlds6f31w-0{list-style-type:none}ul.lst-kix_b4zwlds6f31w-1{list-style-type:none}ul.lst-kix_b4zwlds6f31w-2{list-style-type:none}.lst-kix_doe34qsvg1pd-0>li:before{content:"\0025cf  "}.lst-kix_dam61a68r3zx-2>li:before{content:"\0025a0  "}ul.lst-kix_b4zwlds6f31w-3{list-style-type:none}.lst-kix_fxxo4x7dhkhu-4>li:before{content:"\0025cb  "}.lst-kix_9a8vxc4ia7ct-5>li:before{content:"\0025a0  "}.lst-kix_asj4vxxj20d3-1>li:before{content:"\0025cb  "}.lst-kix_asj4vxxj20d3-0>li:before{content:"\0025cf  "}.lst-kix_asj4vxxj20d3-4>li:before{content:"\0025cb  "}.lst-kix_3a3vs7gz3k6b-5>li:before{content:"\0025a0  "}.lst-kix_3a3vs7gz3k6b-6>li:before{content:"\0025cf  "}.lst-kix_9a8vxc4ia7ct-6>li:before{content:"\0025cf  "}.lst-kix_fxxo4x7dhkhu-0>li:before{content:"\0025cf  "}ul.lst-kix_9a8vxc4ia7ct-5{list-style-type:none}ul.lst-kix_9a8vxc4ia7ct-4{list-style-type:none}.lst-kix_asj4vxxj20d3-5>li:before{content:"\0025a0  "}ul.lst-kix_9a8vxc4ia7ct-7{list-style-type:none}ul.lst-kix_9a8vxc4ia7ct-6{list-style-type:none}ul.lst-kix_9a8vxc4ia7ct-8{list-style-type:none}.lst-kix_fxxo4x7dhkhu-1>li:before{content:"\0025cb  "}ul.lst-kix_9a8vxc4ia7ct-1{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-7{list-style-type:none}ul.lst-kix_9a8vxc4ia7ct-0{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-8{list-style-type:none}ul.lst-kix_9a8vxc4ia7ct-3{list-style-type:none}ul.lst-kix_9a8vxc4ia7ct-2{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-3{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-4{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-5{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-6{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-0{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-1{list-style-type:none}ul.lst-kix_8vndm4gbn4ci-2{list-style-type:none}.lst-kix_ngi8s7ju6o3u-0>li:before{content:"\0025cf  "}.lst-kix_ngi8s7ju6o3u-4>li:before{content:"\0025cb  "}.lst-kix_7aani3dcd0w3-8>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-8}.lst-kix_ngi8s7ju6o3u-8>li:before{content:"\0025a0  "}.lst-kix_o5qrq9ipmu9v-0>li:before{content:"\0025cf  "}.lst-kix_enlqsq9z2ad9-0>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-0}.lst-kix_8vi5oc8p4pg0-2>li:before{content:"\0025a0  "}.lst-kix_9a8vxc4ia7ct-2>li:before{content:"\0025a0  "}.lst-kix_o5qrq9ipmu9v-4>li:before{content:"\0025cb  "}.lst-kix_o5qrq9ipmu9v-8>li:before{content:"\0025a0  "}ul.lst-kix_o5qrq9ipmu9v-4{list-style-type:none}.lst-kix_ds3uygkxmu1a-6>li:before{content:"\0025cf  "}ul.lst-kix_o5qrq9ipmu9v-5{list-style-type:none}ul.lst-kix_o5qrq9ipmu9v-2{list-style-type:none}ul.lst-kix_o5qrq9ipmu9v-3{list-style-type:none}ul.lst-kix_o5qrq9ipmu9v-0{list-style-type:none}.lst-kix_pflig4lw612i-5>li:before{content:"\0025a0  "}ul.lst-kix_o5qrq9ipmu9v-1{list-style-type:none}.lst-kix_ds3uygkxmu1a-2>li:before{content:"\0025a0  "}.lst-kix_8vi5oc8p4pg0-6>li:before{content:"\0025cf  "}.lst-kix_pflig4lw612i-1>li:before{content:"\0025cb  "}.lst-kix_m7pghtu66va-6>li:before{content:"\0025cf  "}.lst-kix_6y1ttbq1ogav-8>li:before{content:"\0025a0  "}.lst-kix_j1holzs3xttc-0>li:before{content:"\0025cf  "}.lst-kix_m7pghtu66va-2>li:before{content:"\0025a0  "}.lst-kix_1ls56psqdc4w-1>li:before{content:"\0025cb  "}ul.lst-kix_gpuswq30cw3b-1{list-style-type:none}ul.lst-kix_gpuswq30cw3b-0{list-style-type:none}ul.lst-kix_gpuswq30cw3b-3{list-style-type:none}.lst-kix_6y1ttbq1ogav-0>li:before{content:"\0025cf  "}ul.lst-kix_gpuswq30cw3b-2{list-style-type:none}ul.lst-kix_htaxbahyi9ac-1{list-style-type:none}ul.lst-kix_gpuswq30cw3b-5{list-style-type:none}ul.lst-kix_htaxbahyi9ac-0{list-style-type:none}ul.lst-kix_gpuswq30cw3b-4{list-style-type:none}ul.lst-kix_htaxbahyi9ac-3{list-style-type:none}ul.lst-kix_gpuswq30cw3b-7{list-style-type:none}ul.lst-kix_htaxbahyi9ac-2{list-style-type:none}ul.lst-kix_gpuswq30cw3b-6{list-style-type:none}ul.lst-kix_htaxbahyi9ac-5{list-style-type:none}ul.lst-kix_htaxbahyi9ac-4{list-style-type:none}ul.lst-kix_gpuswq30cw3b-8{list-style-type:none}ul.lst-kix_htaxbahyi9ac-7{list-style-type:none}.lst-kix_6y1ttbq1ogav-4>li:before{content:"\0025cb  "}ul.lst-kix_htaxbahyi9ac-6{list-style-type:none}ul.lst-kix_htaxbahyi9ac-8{list-style-type:none}.lst-kix_1ls56psqdc4w-5>li:before{content:"\0025a0  "}.lst-kix_yqe02awvv2ik-3>li:before{content:"\0025cf  "}.lst-kix_j1holzs3xttc-8>li:before{content:"\0025a0  "}.lst-kix_1zjhbx5yuacx-6>li:before{content:"\0025cf  "}.lst-kix_99z3queijxrv-1>li:before{content:"\0025cb  "}.lst-kix_j1holzs3xttc-4>li:before{content:"\0025cb  "}.lst-kix_1zjhbx5yuacx-2>li:before{content:"\0025a0  "}.lst-kix_99z3queijxrv-5>li:before{content:"\0025a0  "}.lst-kix_yqe02awvv2ik-7>li:before{content:"\0025cb  "}.lst-kix_hh9fkajeox2u-2>li:before{content:"\0025a0  "}.lst-kix_7x9dfnwo95qd-3>li:before{content:"\0025cf  "}.lst-kix_g58d2ggy4gc1-0>li:before{content:"\0025cf  "}.lst-kix_7x9dfnwo95qd-1>li:before{content:"\0025cb  "}.lst-kix_g58d2ggy4gc1-2>li:before{content:"\0025a0  "}.lst-kix_junjfpk3lk1m-7>li:before{content:"\0025cb  "}.lst-kix_7x9dfnwo95qd-6>li:before{content:"\0025cf  "}.lst-kix_1vd5g4tj2m3r-5>li:before{content:"\0025a0  "}.lst-kix_g58d2ggy4gc1-3>li:before{content:"\0025cf  "}.lst-kix_7x9dfnwo95qd-8>li:before{content:"\0025a0  "}.lst-kix_1vd5g4tj2m3r-7>li:before{content:"\0025cb  "}.lst-kix_7x9dfnwo95qd-0>li:before{content:"\0025cf  "}ul.lst-kix_hegj95gd5bm4-0{list-style-type:none}ul.lst-kix_hegj95gd5bm4-1{list-style-type:none}.lst-kix_yqe02awvv2ik-0>li:before{content:"\0025cf  "}ul.lst-kix_hegj95gd5bm4-2{list-style-type:none}ul.lst-kix_hegj95gd5bm4-3{list-style-type:none}.lst-kix_uox1zzti676w-6>li:before{content:"\0025cf  "}.lst-kix_g58d2ggy4gc1-5>li:before{content:"\0025a0  "}.lst-kix_g58d2ggy4gc1-8>li:before{content:"\0025a0  "}.lst-kix_enlqsq9z2ad9-8>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-8}ul.lst-kix_hegj95gd5bm4-8{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-8{list-style-type:none}.lst-kix_1vd5g4tj2m3r-4>li:before{content:"\0025cb  "}ul.lst-kix_hegj95gd5bm4-4{list-style-type:none}.lst-kix_1vd5g4tj2m3r-2>li:before{content:"\0025a0  "}ul.lst-kix_hegj95gd5bm4-5{list-style-type:none}ul.lst-kix_hegj95gd5bm4-6{list-style-type:none}ul.lst-kix_hegj95gd5bm4-7{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-1{list-style-type:none}ul.lst-kix_lozxriuee1k8-0{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-0{list-style-type:none}ul.lst-kix_lozxriuee1k8-1{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-3{list-style-type:none}ul.lst-kix_lozxriuee1k8-2{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-2{list-style-type:none}ul.lst-kix_lozxriuee1k8-3{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-5{list-style-type:none}ul.lst-kix_lozxriuee1k8-4{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-4{list-style-type:none}ul.lst-kix_lozxriuee1k8-5{list-style-type:none}ul.lst-kix_i3c8vb9n7x7o-7{list-style-type:none}ul.lst-kix_lozxriuee1k8-6{list-style-type:none}.lst-kix_enlqsq9z2ad9-4>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-4}ul.lst-kix_i3c8vb9n7x7o-6{list-style-type:none}ul.lst-kix_lozxriuee1k8-7{list-style-type:none}ul.lst-kix_lozxriuee1k8-8{list-style-type:none}ul.lst-kix_o5qrq9ipmu9v-8{list-style-type:none}ul.lst-kix_o5qrq9ipmu9v-6{list-style-type:none}ul.lst-kix_k5sh93b5y13o-0{list-style-type:none}ul.lst-kix_o5qrq9ipmu9v-7{list-style-type:none}.lst-kix_3n4k5copjjhj-3>li:before{content:"\0025cf  "}.lst-kix_junjfpk3lk1m-2>li:before{content:"\0025a0  "}.lst-kix_junjfpk3lk1m-4>li:before{content:"\0025cb  "}.lst-kix_3n4k5copjjhj-1>li:before{content:"\0025cb  "}.lst-kix_junjfpk3lk1m-5>li:before{content:"\0025a0  "}.lst-kix_3n4k5copjjhj-6>li:before{content:"\0025cf  "}.lst-kix_3n4k5copjjhj-4>li:before{content:"\0025cb  "}.lst-kix_ngi8s7ju6o3u-1>li:before{content:"\0025cb  "}ul.lst-kix_j7pwumu6gnqz-0{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-1{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-2{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-3{list-style-type:none}.lst-kix_ngi8s7ju6o3u-3>li:before{content:"\0025cf  "}.lst-kix_i3c8vb9n7x7o-2>li:before{content:"\0025a0  "}ul.lst-kix_1uiq9wd1knsy-2{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-1{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-4{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-3{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-6{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-5{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-8{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-7{list-style-type:none}.lst-kix_8vi5oc8p4pg0-1>li:before{content:"\0025cb  "}.lst-kix_6x0rcrvd8q7c-5>li:before{content:"\0025a0  "}ol.lst-kix_enlqsq9z2ad9-8{list-style-type:none}.lst-kix_8ian3glbwk9e-6>li:before{content:"\0025cf  "}ol.lst-kix_enlqsq9z2ad9-6{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-7{list-style-type:none}.lst-kix_o5qrq9ipmu9v-3>li:before{content:"\0025cf  "}ul.lst-kix_k5sh93b5y13o-2{list-style-type:none}ul.lst-kix_k5sh93b5y13o-1{list-style-type:none}ul.lst-kix_k5sh93b5y13o-4{list-style-type:none}ul.lst-kix_k5sh93b5y13o-3{list-style-type:none}.lst-kix_o5qrq9ipmu9v-1>li:before{content:"\0025cb  "}ul.lst-kix_k5sh93b5y13o-6{list-style-type:none}ul.lst-kix_k5sh93b5y13o-5{list-style-type:none}ul.lst-kix_k5sh93b5y13o-8{list-style-type:none}ul.lst-kix_1uiq9wd1knsy-0{list-style-type:none}ul.lst-kix_k5sh93b5y13o-7{list-style-type:none}.lst-kix_i3c8vb9n7x7o-4>li:before{content:"\0025cb  "}.lst-kix_8ian3glbwk9e-0>li:before{content:"\0025cf  "}ul.lst-kix_j1holzs3xttc-4{list-style-type:none}ul.lst-kix_j1holzs3xttc-5{list-style-type:none}ul.lst-kix_j1holzs3xttc-2{list-style-type:none}ul.lst-kix_j1holzs3xttc-3{list-style-type:none}.lst-kix_m7pghtu66va-3>li:before{content:"\0025cf  "}ul.lst-kix_j1holzs3xttc-8{list-style-type:none}.lst-kix_8vi5oc8p4pg0-7>li:before{content:"\0025cb  "}ul.lst-kix_j1holzs3xttc-6{list-style-type:none}ul.lst-kix_j1holzs3xttc-7{list-style-type:none}.lst-kix_m7pghtu66va-5>li:before{content:"\0025a0  "}ol.lst-kix_enlqsq9z2ad9-4{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-5{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-2{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-3{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-0{list-style-type:none}ul.lst-kix_j1holzs3xttc-0{list-style-type:none}ol.lst-kix_enlqsq9z2ad9-1{list-style-type:none}ul.lst-kix_j1holzs3xttc-1{list-style-type:none}.lst-kix_o9kmpjmc1djl-1>li:before{content:"\0025cb  "}.lst-kix_6y1ttbq1ogav-7>li:before{content:"\0025cb  "}.lst-kix_je8f38j0gr98-7>li:before{content:"\0025cb  "}.lst-kix_1ls56psqdc4w-0>li:before{content:"\0025cf  "}.lst-kix_6y1ttbq1ogav-5>li:before{content:"\0025a0  "}.lst-kix_je8f38j0gr98-1>li:before{content:"\0025cb  "}.lst-kix_o9kmpjmc1djl-3>li:before{content:"\0025cf  "}.lst-kix_k7md3c5ksz8x-4>li:before{content:"\0025cb  "}.lst-kix_1uiq9wd1knsy-3>li:before{content:"\0025cf  "}.lst-kix_1ls56psqdc4w-8>li:before{content:"\0025a0  "}.lst-kix_k7md3c5ksz8x-6>li:before{content:"\0025cf  "}.lst-kix_1ls56psqdc4w-6>li:before{content:"\0025cf  "}.lst-kix_6x0rcrvd8q7c-7>li:before{content:"\0025cb  "}.lst-kix_1uiq9wd1knsy-5>li:before{content:"\0025a0  "}.lst-kix_uox1zzti676w-3>li:before{content:"\0025cf  "}.lst-kix_jmpizlww91eb-4>li:before{content:"\0025cb  "}.lst-kix_8ian3glbwk9e-8>li:before{content:"\0025a0  "}.lst-kix_jmpizlww91eb-6>li:before{content:"\0025cf  "}.lst-kix_yqe02awvv2ik-2>li:before{content:"\0025a0  "}.lst-kix_uox1zzti676w-1>li:before{content:"\0025cb  "}.lst-kix_54rh6a6ewprb-4>li:before{content:"\0025cb  "}.lst-kix_54rh6a6ewprb-2>li:before{content:"\0025a0  "}ul.lst-kix_doe34qsvg1pd-3{list-style-type:none}ul.lst-kix_1ls56psqdc4w-1{list-style-type:none}ul.lst-kix_doe34qsvg1pd-2{list-style-type:none}ul.lst-kix_1ls56psqdc4w-0{list-style-type:none}.lst-kix_yqe02awvv2ik-8>li:before{content:"\0025a0  "}ul.lst-kix_doe34qsvg1pd-5{list-style-type:none}ul.lst-kix_doe34qsvg1pd-4{list-style-type:none}ul.lst-kix_doe34qsvg1pd-7{list-style-type:none}ul.lst-kix_doe34qsvg1pd-6{list-style-type:none}ul.lst-kix_doe34qsvg1pd-8{list-style-type:none}.lst-kix_1zjhbx5yuacx-5>li:before{content:"\0025a0  "}ul.lst-kix_j7pwumu6gnqz-4{list-style-type:none}ul.lst-kix_1ls56psqdc4w-8{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-5{list-style-type:none}.lst-kix_7aani3dcd0w3-6>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-6}ul.lst-kix_1ls56psqdc4w-7{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-6{list-style-type:none}.lst-kix_hh9fkajeox2u-1>li:before{content:"\0025cb  "}ul.lst-kix_1ls56psqdc4w-6{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-7{list-style-type:none}.lst-kix_1zjhbx5yuacx-3>li:before{content:"\0025cf  "}ul.lst-kix_1ls56psqdc4w-5{list-style-type:none}ul.lst-kix_j7pwumu6gnqz-8{list-style-type:none}ul.lst-kix_1ls56psqdc4w-4{list-style-type:none}ul.lst-kix_doe34qsvg1pd-1{list-style-type:none}ul.lst-kix_1ls56psqdc4w-3{list-style-type:none}ul.lst-kix_doe34qsvg1pd-0{list-style-type:none}ul.lst-kix_1ls56psqdc4w-2{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-6{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-5{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-8{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-7{list-style-type:none}.lst-kix_k5sh93b5y13o-2>li:before{content:"\0025a0  "}.lst-kix_sspruoj0x7ey-2>li:before{content:"\0025a0  "}.lst-kix_k5sh93b5y13o-5>li:before{content:"\0025a0  "}ul.lst-kix_q4pfpg5v40ry-0{list-style-type:none}.lst-kix_gpuswq30cw3b-8>li:before{content:"\0025a0  "}ul.lst-kix_q4pfpg5v40ry-2{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-1{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-4{list-style-type:none}ul.lst-kix_q4pfpg5v40ry-3{list-style-type:none}.lst-kix_7aani3dcd0w3-2>li{counter-increment:lst-ctn-kix_7aani3dcd0w3-2}.lst-kix_hh9fkajeox2u-7>li:before{content:"\0025cb  "}.lst-kix_htaxbahyi9ac-6>li:before{content:"\0025cf  "}.lst-kix_gpuswq30cw3b-3>li:before{content:"\0025cf  "}ul.lst-kix_pflig4lw612i-0{list-style-type:none}ul.lst-kix_pflig4lw612i-1{list-style-type:none}ul.lst-kix_pflig4lw612i-2{list-style-type:none}ul.lst-kix_pflig4lw612i-3{list-style-type:none}.lst-kix_sspruoj0x7ey-7>li:before{content:"\0025cb  "}.lst-kix_px80xspa50tp-8>li:before{content:"\0025a0  "}.lst-kix_g47nti3zp8ay-7>li:before{content:"\0025cb  "}.lst-kix_doe34qsvg1pd-5>li:before{content:"\0025a0  "}.lst-kix_fxxo4x7dhkhu-7>li:before{content:"\0025cb  "}.lst-kix_px80xspa50tp-5>li:before{content:"\0025a0  "}.lst-kix_caf22lmip6rs-6>li:before{content:"\0025cf  "}.lst-kix_gpuswq30cw3b-0>li:before{content:"\0025cf  "}ul.lst-kix_3n4k5copjjhj-6{list-style-type:none}ul.lst-kix_3n4k5copjjhj-7{list-style-type:none}.lst-kix_caf22lmip6rs-3>li:before{content:"\0025cf  "}ul.lst-kix_3n4k5copjjhj-8{list-style-type:none}.lst-kix_px80xspa50tp-0>li:before{content:"\0025cf  "}.lst-kix_g47nti3zp8ay-2>li:before{content:"\0025a0  "}ul.lst-kix_3n4k5copjjhj-0{list-style-type:none}ul.lst-kix_3n4k5copjjhj-1{list-style-type:none}ul.lst-kix_3n4k5copjjhj-2{list-style-type:none}ul.lst-kix_3n4k5copjjhj-3{list-style-type:none}ul.lst-kix_3n4k5copjjhj-4{list-style-type:none}ul.lst-kix_3n4k5copjjhj-5{list-style-type:none}.lst-kix_8vndm4gbn4ci-6>li:before{content:"\0025cf  "}.lst-kix_m7pghtu66va-8>li:before{content:"\0025a0  "}ul.lst-kix_6x0rcrvd8q7c-1{list-style-type:none}ul.lst-kix_6x0rcrvd8q7c-2{list-style-type:none}ul.lst-kix_6x0rcrvd8q7c-0{list-style-type:none}.lst-kix_doe34qsvg1pd-2>li:before{content:"\0025a0  "}.lst-kix_dam61a68r3zx-4>li:before{content:"\0025cb  "}.lst-kix_8vndm4gbn4ci-1>li:before{content:"\0025cb  "}ul.lst-kix_6x0rcrvd8q7c-7{list-style-type:none}ul.lst-kix_6x0rcrvd8q7c-8{list-style-type:none}.lst-kix_dam61a68r3zx-1>li:before{content:"\0025cb  "}ul.lst-kix_6x0rcrvd8q7c-5{list-style-type:none}ul.lst-kix_6x0rcrvd8q7c-6{list-style-type:none}ul.lst-kix_6x0rcrvd8q7c-3{list-style-type:none}ul.lst-kix_6x0rcrvd8q7c-4{list-style-type:none}.lst-kix_3a3vs7gz3k6b-4>li:before{content:"\0025cb  "}.lst-kix_9a8vxc4ia7ct-4>li:before{content:"\0025cb  "}.lst-kix_asj4vxxj20d3-3>li:before{content:"\0025cf  "}.lst-kix_fxxo4x7dhkhu-2>li:before{content:"\0025a0  "}.lst-kix_asj4vxxj20d3-6>li:before{content:"\0025cf  "}.lst-kix_3a3vs7gz3k6b-7>li:before{content:"\0025cb  "}.lst-kix_9a8vxc4ia7ct-7>li:before{content:"\0025cb  "}ul.lst-kix_3a3vs7gz3k6b-0{list-style-type:none}.lst-kix_enlqsq9z2ad9-1>li{counter-increment:lst-ctn-kix_enlqsq9z2ad9-1}ul.lst-kix_3a3vs7gz3k6b-4{list-style-type:none}ul.lst-kix_3a3vs7gz3k6b-3{list-style-type:none}ul.lst-kix_3a3vs7gz3k6b-2{list-style-type:none}ul.lst-kix_3a3vs7gz3k6b-1{list-style-type:none}.lst-kix_7aani3dcd0w3-3>li:before{content:"" counter(lst-ctn-kix_7aani3dcd0w3-3,decimal) ". "}.lst-kix_8vi5oc8p4pg0-4>li:before{content:"\0025cb  "}ul.lst-kix_3a3vs7gz3k6b-8{list-style-type:none}.lst-kix_b4zwlds6f31w-5>li:before{content:"\0025a0  "}.lst-kix_6w9khmgz918g-5>li:before{content:"\0025a0  "}ul.lst-kix_3a3vs7gz3k6b-7{list-style-type:none}ul.lst-kix_3a3vs7gz3k6b-6{list-style-type:none}.lst-kix_ngi8s7ju6o3u-6>li:before{content:"\0025cf  "}ul.lst-kix_3a3vs7gz3k6b-5{list-style-type:none}.lst-kix_6x0rcrvd8q7c-2>li:before{content:"\0025a0  "}.lst-kix_8ian3glbwk9e-3>li:before{content:"\0025cf  "}.lst-kix_lozxriuee1k8-7>li:before{content:"\0025cb  "}ul.lst-kix_m7pghtu66va-7{list-style-type:none}ul.lst-kix_m7pghtu66va-6{list-style-type:none}ul.lst-kix_m7pghtu66va-8{list-style-type:none}.lst-kix_enlqsq9z2ad9-3>li:before{content:"" counter(lst-ctn-kix_enlqsq9z2ad9-3,decimal) ". "}.lst-kix_ds3uygkxmu1a-4>li:before{content:"\0025cb  "}.lst-kix_i3c8vb9n7x7o-7>li:before{content:"\0025cb  "}.lst-kix_9r9qns1l7tou-0>li:before{content:"\0025cf  "}.lst-kix_o5qrq9ipmu9v-6>li:before{content:"\0025cf  "}.lst-kix_k7md3c5ksz8x-1>li:before{content:"\0025cb  "}ul.lst-kix_dam61a68r3zx-1{list-style-type:none}ul.lst-kix_dam61a68r3zx-0{list-style-type:none}.lst-kix_1ls56psqdc4w-3>li:before{content:"\0025cf  "}ul.lst-kix_dam61a68r3zx-5{list-style-type:none}ul.lst-kix_dam61a68r3zx-4{list-style-type:none}ul.lst-kix_dam61a68r3zx-3{list-style-type:none}.lst-kix_1uiq9wd1knsy-8>li:before{content:"\0025a0  "}.lst-kix_99z3queijxrv-7>li:before{content:"\0025cb  "}ul.lst-kix_dam61a68r3zx-2{list-style-type:none}ul.lst-kix_dam61a68r3zx-8{list-style-type:none}ul.lst-kix_dam61a68r3zx-7{list-style-type:none}ul.lst-kix_dam61a68r3zx-6{list-style-type:none}.lst-kix_pflig4lw612i-7>li:before{content:"\0025cb  "}.lst-kix_q4pfpg5v40ry-7>li:before{content:"\0025cb  "}.lst-kix_m7pghtu66va-0>li:before{content:"\0025cf  "}.lst-kix_o9kmpjmc1djl-6>li:before{content:"\0025cf  "}.lst-kix_6y1ttbq1ogav-2>li:before{content:"\0025a0  "}.lst-kix_9r9qns1l7tou-8>li:before{content:"\0025a0  "}.lst-kix_je8f38j0gr98-4>li:before{content:"\0025cb  "}.lst-kix_1zjhbx5yuacx-8>li:before{content:"\0025a0  "}.lst-kix_htaxbahyi9ac-3>li:before{content:"\0025cf  "}.lst-kix_1uiq9wd1knsy-0>li:before{content:"\0025cf  "}.lst-kix_yqe02awvv2ik-5>li:before{content:"\0025a0  "}.lst-kix_1zjhbx5yuacx-0>li:before{content:"\0025cf  "}ul.lst-kix_ngi8s7ju6o3u-7{list-style-type:none}ul.lst-kix_sspruoj0x7ey-8{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-8{list-style-type:none}ul.lst-kix_sspruoj0x7ey-6{list-style-type:none}ul.lst-kix_sspruoj0x7ey-7{list-style-type:none}ul.lst-kix_sspruoj0x7ey-4{list-style-type:none}.lst-kix_hh9fkajeox2u-4>li:before{content:"\0025cb  "}ul.lst-kix_sspruoj0x7ey-5{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-1{list-style-type:none}ul.lst-kix_sspruoj0x7ey-2{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-2{list-style-type:none}ul.lst-kix_sspruoj0x7ey-3{list-style-type:none}.lst-kix_jmpizlww91eb-1>li:before{content:"\0025cb  "}ul.lst-kix_sspruoj0x7ey-0{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-0{list-style-type:none}ul.lst-kix_sspruoj0x7ey-1{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-5{list-style-type:none}.lst-kix_54rh6a6ewprb-7>li:before{content:"\0025cb  "}.lst-kix_j1holzs3xttc-2>li:before{content:"\0025a0  "}ul.lst-kix_ngi8s7ju6o3u-6{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-3{list-style-type:none}ul.lst-kix_ngi8s7ju6o3u-4{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c17{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:402.8pt;border-top-color:#000000;border-bottom-style:solid}.c10{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:101.7pt;border-top-color:#000000;border-bottom-style:solid}.c4{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:508.5pt;border-top-color:#000000;border-bottom-style:solid}.c24{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:60.8pt;border-top-color:#000000;border-bottom-style:solid}.c49{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:309pt;border-top-color:#000000;border-bottom-style:solid}.c44{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:115.5pt;border-top-color:#000000;border-bottom-style:solid}.c36{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:97.5pt;border-top-color:#000000;border-bottom-style:solid}.c52{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:54.8pt;border-top-color:#000000;border-bottom-style:solid}.c15{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:494.2pt;border-top-color:#000000;border-bottom-style:solid}.c21{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:254.2pt;border-top-color:#000000;border-bottom-style:solid}.c33{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:112.5pt;border-top-color:#000000;border-bottom-style:solid}.c45{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:324.8pt;border-top-color:#000000;border-bottom-style:solid}.c12{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c2{margin-left:72pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c41{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c28{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c19{margin-left:18pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c1{margin-left:54pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c32{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c30{margin-left:36pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c20{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c16{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c39{padding-top:10pt;padding-bottom:4pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c62{padding-top:4pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c29{padding-top:14pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c57{padding-top:10pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c42{padding-top:20pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c9{padding-top:10pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c27{padding-top:18pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c31{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c54{padding-top:10pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c46{padding-top:10pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c22{padding-top:10pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c59{padding-top:0pt;padding-bottom:4pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left;height:11pt}.c60{font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c50{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c56{margin-left:36.8pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c40{margin-left:36pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c18{border-spacing:0;border-collapse:collapse;margin-right:auto}.c63{background-color:#ffffff;max-width:508.5pt;padding:72pt 36pt 72pt 67.5pt}.c8{padding:0;margin:0}.c25{margin-left:36pt;padding-left:0pt}.c53{margin-left:108pt;padding-left:0pt}.c23{color:inherit;text-decoration:inherit}.c37{margin-left:72pt;padding-left:0pt}.c43{color:#999999}.c35{height:11pt}.c34{height:51.2pt}.c61{color:#666666}.c55{font-style:italic}.c6{height:0pt}.c58{color:#38761d}.c48{font-size:11pt}.c11{font-weight:700}.c51{margin-left:72pt}.c47{margin-left:36pt}.c26{page-break-after:avoid}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c63 doc-content"><p class="c16 c35"><span class="c0"></span></p><p class="c62"><span class="c12"><a class="c23" href="#h.2mkkr4bqraie">Java Virtual Machine</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.oy7i8np2dw">HotSpot JVM</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.h46xybnv67go">Memory</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.3lwjegc20sp1">Java Heap Space</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.q4fnhysyrm0i">Java String Pool</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.vx5hs0hwupfn">Java Integer Cache</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.6nlekll4r2">JVM Code Cache</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.hkkvtelekqbn">Java Stack Memory</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.s0uxulnvpi4d">Classloaders</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.lgea6zfq9jhh">Garbage Collection</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.q16k3ghs70ri">Serial Garbage Collector</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.a5tfgcwsul6b">Parallel Garbage Collector</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.dvyxh2ofc6u9">CMS Garbage Collector</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.53wry4k6q14o">G1 Garbage Collector</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.nzhrlty6nrw2">Shenandoah Garbage Collector</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.n06ayh15lhza">ZGC Garbage Collector</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.k1bj2or9nisv">Data Types</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.cu021hq0bhf4">Primitive Data Types</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.6ir928h87wok">Reference Data Types</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.3zwuem1pqyt5">Strong references</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.bdha5rlh614h">Weak references</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.l58ug3igqiv2">Soft references</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.u2ecmnv25o62">Phantom references</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.re9p466rm724">Arrays</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.kymipayaph1d">Java OOP</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.815rcraha9w6">Abstraction</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.pxsjwu5ph3hx">Encapsulation</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.j8q5tb3yve30">Inheritance</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.y4594oc1oeq9">Polymorphism</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.71ce8yyblktk">Class Casting</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.iuix14k02sc7">Compile-time vs Runtime polymorphism</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.jbeo3nf5ene5">Final</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.y2mdk9fpsl9a">Static</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.p3ciqssm30p">Initialization order</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.gwbo50rboqkb">Composition vs Inheritance</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.wkn9iloqgzay">Nested classes</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.mm6gg57kgt6d">Shadowing</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.ctjfqnfyns5h">Collections</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.s3mryiq9cwqj">Collection</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.uiuam2zbcmjh">Iterable</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.tbwwtn6lcuo3">Iterator</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.qilfk793yp2d">ConcurrentModificationException</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.80k7vbcq0ov4">List</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.r7eg3hn4zqg1">ArrayList</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.jvt3w4ca73nt">LinkedList</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.60gs7qz0lib">The Problem of Linked-List</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.45pfk0zhzxab">Performance of Array vs Linked-List</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.nrkdkc7oi47p">Map</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.6hje4ynqsh46">HashMap</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.lw8hi88s9ia">Fixed HashCode issue</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.1wnbyh5zybnv">Array-as-key issue</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.4v7o4putoqk7">LinkedHashMap</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.h4n6965qnfbs">TreeMap</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.jrtpjynz3t90">WeakHashMap</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.at74xkebnqyo">Set</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.b4cgsd75mj3w">HashSet</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.f429fs5mtpc7">LinkedHashSet</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.5x2zpaolc6lw">TreeSet</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.k2us0n3j21ox">Queue</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.k9t42x89wwp5">BlockingQueue</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.gbgknwblt5mp">PriorityBlockingQueue</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.xya7355meygr">SynchronousQueue</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.vnabw3hfkex7">ArrayBlockingQueue</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.gf5mbif9h4hz">LinkedBlockingQueue</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.n977wt22ug8m">Thread-safe collections</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.t21gm2hqtdn2">Synchronized collections</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.fyflm8vgmw2x">Concurrent collections</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.oexb0ef8og7o">CopyOnWriteArray</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.9ho82fbyktpz">CopyOnWriteArrayList</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.xyxitcdjo4i9">CopyOnWriteArraySet</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.cxwxlowjheh2">Exceptions</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.ovhvbl77qmok">Checked vs Unchecked</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.11m92bv6ata">Try-with-resources</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.hc7srdu9kewn">Generics</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.dvqax9chic7e">Bounded Type Parameters</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.ushqcul1ovn4">Generic Classes</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.ta1x1b5ed4xn">Type Erasure</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.4uxq25wvd5mz">Wildcards</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.cvuxfjqdmso2">Wildcard Guidelines</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.21ty5dsrzwiy">QA</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.b93nh51ozwk">Functional Programming</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.s83jkugrqaeo">Java Stream API</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.fwy95ym89xg2">Stream creation</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.b5eamwoup21u">Stream transformation</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.gu692zq8hjm7">Stream termination</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.egfp6wya7dua">Reduce</a></span></p><p class="c1"><span class="c12"><a class="c23" href="#h.600yvu61w6uh">Collect</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.t4nyk1nq6l15">Parallel Stream</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.9mdff64vwe4t">Optional</a></span></p><p class="c46"><span class="c12"><a class="c23" href="#h.jwfw7nhe0unf">Concurrency</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.5xmrelmixc5n">Java Memory Model</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.njcvtdhf83ie">Hardware Memory Architecture</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.oz8vuysludyk">Thread</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.a1w5auc8ftlr">Visibility and Happens-Before</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.adwlb39dxsyn">volatile keyword</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.36iwa5cip18o">synchronized keyword</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.atjff4edv7ql">Race Condition</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.w99adfk8pgp">Compare-And-Swap</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.o1oios646utc">Locks</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.stdk67qt8a3">Executors</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.3kbxf86646s2">Coordination of threads</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.1un2r3csngz3">CountDownLatch</a></span></p><p class="c30"><span class="c12"><a class="c23" href="#h.alacdu7r3m4j">Phaser</a></span></p><p class="c19"><span class="c12"><a class="c23" href="#h.8bkgkhaiiwbg">ThreadLocal</a></span></p><p class="c39"><span class="c12"><a class="c23" href="#h.2pev7b12kbbd">Changelog. What&rsquo;s new</a></span></p><p class="c16 c35"><span class="c0"></span></p><h1 class="c42 c26" id="h.2mkkr4bqraie"><span class="c38">Java Virtual Machine</span></h1><p class="c9"><span class="c0">A Java Virtual Machine (JVM) is an imaginary computer that has never been physically built as hardware. A JVM runs programs compiled to its imaginary instruction set written to storage as an intermediate representation known as bytecode.</span></p><p class="c9"><span class="c0">At runtime, the bytecode must be translated from the imaginary instruction set to the actual instruction set of the CPU of the host machine. This can be done on-the-fly by an interpreter. Or the bytecode can be fully compiled and cached, to run faster than through the interpreter, in a process known as Just-In-Time (JIT) compiling.</span></p><p class="c9"><span class="c0">Over the decades, there have been many implementations of the JVM. Most have fallen away.</span></p><p class="c54"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 345.50px; height: 387.09px;"><img alt="" src="images/image9.png" style="width: 345.50px; height: 387.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c11">HotSpot</span><span>&nbsp;is one implementation of JIT technology that starts by running interpreted, and watches the actual performance of the app. Parts of the app are then selected to be fully-compiled as native code and cached, for much faster execution. HotSpot was developed at Sun as a commercial product. After acquiring Sun, Oracle further evolved HotSpot by combining important parts of their competing product, JRockit. HotSpot is now open-sourced through the </span><span class="c11">OpenJDK</span><span class="c0">&nbsp;project, available free-of-charge.</span></p><p class="c9"><span>Another such implementation in </span><span class="c11">OpenJ9</span><span class="c0">, developed by IBM, and now open-sourced through the Eclipse Foundation and available free-of-charge. Some JVM distributions built on OpenJDK replace HotSpot with OpenJ9 while still using the rest of OpenJDK such as the Java SE class libraries. For example, the pre-built distributions available at AdoptOpenJDK provide your choice of HotSpot or OpenJ9 on some hardware.</span></p><p class="c9"><span class="c11">AdoptOpenJDK</span><span>&nbsp;- open and reproducible build &amp; test system for OpenJDK source across multiple platforms. AdoptOpenJDK provides rock-solid OpenJDK and Eclipse OpenJ9 (with OpenJDK class libraries) binaries for the Java ecosystem and also provides infrastructure as code, and a Build farm for builders of </span><span class="c11">OpenJDK</span><span>&nbsp;and Eclipse </span><span class="c11">OpenJ9</span><span class="c0">&nbsp;(with OpenJDK class libraries), on any platform.</span></p><h2 class="c27 c26" id="h.oy7i8np2dw"><span class="c13">HotSpot JVM</span></h2><p class="c9"><span class="c0">Hotspot provides:</span></p><ul class="c8 lst-kix_6w9khmgz918g-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">A Java Classloader</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A Java bytecode interpreter</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Client and Server virtual machines, optimized for their respective uses</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Several garbage collectors (including a very-low-pause-time ZGC)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A set of supporting runtime libraries</span></li></ul><p class="c9"><span>The HotSpot JDK includes two flavors of the VM -- a </span><span class="c11">client</span><span>-side offering, and a VM tuned for </span><span class="c11">server</span><span class="c0">&nbsp;applications. These two solutions share the Java HotSpot runtime environment code base, but use different compilers that are suited to the distinctly unique performance characteristics of clients and servers. These differences include the compilation inlining policy and heap defaults.</span></p><p class="c9"><span>Although the Server and the Client VMs are similar, the </span><span class="c11">Server VM has been specially tuned to maximize peak operating speed</span><span class="c0">. It is intended for executing long-running server applications, which need the fastest possible operating speed more than a fast start-up time or smaller runtime memory footprint.</span></p><p class="c9"><span>The Client VM compiler serves as an upgrade for both the Classic VM and the just-in-time (JIT) compilers used by previous versions of the JDK. The Client VM offers improved run time performance for applications and applets. The Java </span><span class="c11">HotSpot Client VM has been specially tuned to reduce application start-up time and memory footprint</span><span class="c0">, making it particularly well suited for client environments. In general, the client system is better for GUIs.</span></p><p class="c9"><span class="c0">The Client VM compiler does not try to execute many of the more complex optimizations performed by the compiler in the Server VM, but in exchange, it requires less time to analyze and compile a piece of code. This means the Client VM can start up faster and requires a smaller memory footprint.</span></p><p class="c9"><span>The </span><span class="c11">Server VM contains an advanced adaptive compiler that supports many of the same types of optimizations</span><span>&nbsp;performed by optimizing C++ compilers, as well as some optimizations that cannot be done by traditional compilers, such as </span><span class="c11">aggressive inlining across virtual method invocations</span><span class="c0">. This is a competitive and performance advantage over static compilers. Adaptive optimization technology is very flexible in its approach, and typically outperforms even advanced static analysis and compilation techniques.</span></p><p class="c9"><span class="c31 c11">The 64-bit version of the Java SE Development Kit (JDK) currently ignores this option and instead uses the Server JVM.</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 475.50px; height: 212.52px;"><img alt="" src="images/image2.png" style="width: 475.50px; height: 212.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c0">Some JVM configuration properties: </span></p><ul class="c8 lst-kix_ds3uygkxmu1a-0 start"><li class="c9 c25 li-bullet-0"><span>-Xms - set </span><span class="c31 c11">initial heap size</span></li><li class="c3 c25 li-bullet-0"><span>-Xmx - set </span><span class="c31 c11">maximum heap size</span></li><li class="c3 c25 li-bullet-0"><span>-Xss - set </span><span class="c31 c11">thread stack size</span></li><li class="c3 c25 li-bullet-0"><span class="c0">-verbose:gc - logs garbage collector runs and how long they&#39;re taking. </span></li><li class="c3 c25 li-bullet-0"><span class="c0">-XX:+PrintGCDetails - includes the data from -verbose:gc but also adds information about the size of the new generation and more accurate timings.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">-XX:+PrintGCTimeStamps - Print timestamps at garbage collection.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">-XX:+HeapDumpOnOutOfMemoryError - To trigger heap dump on out of memory</span></li><li class="c3 c25 li-bullet-0"><span class="c0">-XX:+TraceClassLoading - to print logging information whenever classes loads into JVM</span></li><li class="c3 c25 li-bullet-0"><span class="c0">-Xprof - Java Profiling is the process of monitoring various JVM levels parameters such as Method Executions, Thread Executions, Garbage Collections, and Object Creations</span></li><li class="c9 c25 li-bullet-0"><span class="c0">-XX:-OmitStackTraceInFastThrow - disable the optimization that makes the compiler in the server VM stop outputting the stack trace of the exceptions which have been thrown a few times</span></li></ul><h2 class="c27 c26" id="h.h46xybnv67go"><span class="c13">Memory</span></h2><p class="c9"><span class="c0">The Java Virtual Machine (JVM) divides memory between Java Heap Space and Java Stack Memory.</span></p><h3 class="c20" id="h.3lwjegc20sp1"><span class="c32">Java Heap Space</span></h3><p class="c9"><span class="c0">It is created by the Java Virtual Machine when it starts. The memory is used as long as the application is running. When an object is created, it is always created in Heap and has global access. That means all objects can be referenced from anywhere in the application.</span></p><h4 class="c29 c26" id="h.q4fnhysyrm0i"><span class="c41">Java String Pool</span></h4><p class="c9"><span class="c0">When we create a String variable and assign a value to it, the JVM searches the pool for a String of equal value. If found, the Java compiler will simply return a reference to its memory address, without allocating additional memory. If not found, it&#39;ll be added to the pool (interned) and its reference will be returned.</span></p><p class="c9"><span class="c0">From Java 7 onwards, the Java String Pool is stored in the Heap space, which is garbage collected by the JVM. The advantage of this approach is the reduced risk of OutOfMemory error because unreferenced Strings will be removed from the pool, thereby releasing memory.</span></p><h4 class="c29 c26" id="h.vx5hs0hwupfn"><span class="c41">Java Integer Cache</span></h4><p class="c9"><span class="c0">Basically, the Integer class keeps a cache of Integer instances in the range of -128 to 127, and all autoboxing, literals and uses of Integer.valueOf() will return instances from that cache for the range it covers.</span></p><p class="c9"><span class="c0">The purpose is mainly to save memory, which also leads to faster code due to better cache efficiency.</span></p><p class="c9"><span class="c0">This is based on the assumption that these small values occur much more often than other ints and therefore it makes sense to avoid the overhead of having different objects for every instance (an Integer object takes up something like 12 bytes).</span></p><h4 class="c29 c26" id="h.6nlekll4r2"><span class="c41">JVM Code Cache</span></h4><p class="c9"><span class="c0">JVM Code Cache is an area where JVM stores its bytecode compiled into native code. We call each block of the executable native code a nmethod. The nmethod might be a complete or inlined Java method.</span></p><p class="c9"><span>The </span><span class="c11">just-in-time (JIT) compiler is the biggest consumer of the code cache area</span><span class="c0">. That&#39;s why some developers call this memory a JIT code cache.</span></p><h3 class="c20" id="h.hkkvtelekqbn"><span class="c32">Java Stack Memory</span></h3><p class="c9"><span class="c0">This is the temporary memory where variable values are stored when their methods are invoked. After the method is finished, the memory containing those values is cleared to make room for new methods.</span></p><p class="c9"><span class="c0">When a new method is invoked, a new block of memory will be created in the Stack. This new block will store the temporary values invoked by the method and references to objects stored in the Heap that are being used by the method.</span></p><p class="c9"><span class="c0">Any values in this block are only accessible by the current method and will not exist once it ends. When the method ends, that block will be erased. The next method invoked will use that empty block.</span></p><p class="c9"><span class="c0">This &ldquo;last in, first out&rdquo; method makes it easy to find the values needed and allows fast access to those values.</span></p><h2 class="c27 c26" id="h.s0uxulnvpi4d"><span class="c13">Classloaders</span></h2><p class="c9"><span>Class loaders are responsible for </span><span class="c11">loading Java classes during runtime dynamically</span><span class="c0">&nbsp;to the JVM (Java Virtual Machine). Also, they are part of the JRE (Java Runtime Environment). Hence, the JVM doesn&#39;t need to know about the underlying files or file systems in order to run Java programs thanks to class loaders.</span></p><p class="c9"><span class="c0">Also, these Java classes aren&#39;t loaded into memory all at once, but when required by an application. This is where class loaders come into the picture. They are responsible for loading classes into memory.</span></p><p class="c16"><span class="c0">Java classes are loaded by an instance of java.lang.ClassLoader. However, class loaders are classes themselves. The java.lang.ClassLoader itself is loaded by bootstrap class loader.</span></p><ul class="c8 lst-kix_1zjhbx5yuacx-0 start"><li class="c9 c25 li-bullet-0"><span class="c11">Bootstrap Class Loader</span><span>: it is mainly responsible for loading </span><span>JDK internal classes, typically rt.jar and other core libraries located in $JAVA_HOME/jre/lib directory</span><span>. Additionally, Bootstrap class loader serves as a </span><span class="c11">parent</span><span class="c0">&nbsp;of all the other ClassLoader instances. </span></li></ul><p class="c9 c47"><span class="c0">Bootstrap class loader is part of the core JVM and is written in native code. Different platforms might have different implementations of this particular class loader.</span></p><ul class="c8 lst-kix_1zjhbx5yuacx-0"><li class="c3 c25 li-bullet-0"><span class="c11">Extension Class Loader</span><span class="c0">&nbsp;- it is a child of the bootstrap class loader and takes care of loading the extensions of the standard core Java classes so that it&#39;s available to all applications running on the platform. </span></li></ul><p class="c3 c47"><span>Extension class loader loads from the JDK extensions directory, usually </span><span>$JAVA_HOME/lib/ext directory</span><span>&nbsp;or any other directory mentioned in the </span><span class="c0">java.ext.dirs system property.</span></p><ul class="c8 lst-kix_1zjhbx5yuacx-0"><li class="c7 li-bullet-0"><span class="c11">System Class Loader</span><span class="c0">&nbsp;- takes care of loading all the application level classes into the JVM. It loads files found in the classpath environment variable, -classpath or -cp command line option. Also, it&#39;s a child of Extension classloader.</span></li></ul><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 487.10px; height: 269.50px;"><img alt="" src="images/image5.png" style="width: 487.10px; height: 269.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span>Class loaders are part of the Java Runtime Environment. When the JVM requests a class, the class loader tries to locate the class and load the class definition into the runtime </span><span class="c11">using the fully qualified class name</span><span class="c0">.</span></p><p class="c9"><span>The java.lang.ClassLoader.loadClass() method is responsible for loading the class definition into runtime. It tries to load the class based on a fully qualified name. If the class isn&#39;t already loaded, </span><span class="c11">it delegates the request to the parent class loader</span><span class="c0">. This process happens recursively.</span></p><p class="c9"><span class="c0">Eventually, if the parent class loader doesn&rsquo;t find the class, then the child class will call java.net.URLClassLoader.findClass() method to look for classes in the file system itself. If the last child class loader isn&#39;t able to load the class either, it throws java.lang.NoClassDefFoundError or java.lang.ClassNotFoundException.</span></p><p class="c9"><span>The ClassLoader Delegation Hierarchy Model always functions in the order </span><span class="c11">Application ClassLoader-&gt;Extension ClassLoader-&gt;Bootstrap ClassLoader</span><span class="c0">. The Bootstrap ClassLoader is always given the higher priority, next is Extension ClassLoader and then Application ClassLoader.</span></p><h2 class="c27 c26" id="h.lgea6zfq9jhh"><span class="c13">Garbage Collection</span></h2><p class="c9"><span>Java garbage collection is the process by which Java programs perform </span><span class="c11">automatic memory management</span><span class="c0">. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory.</span></p><p class="c9"><span class="c0">The garbage collection implementation lives in the JVM. Each JVM can implement its own version of garbage collection. However, it should meet the standard JVM specification of working with the objects present in the heap memory, marking or identifying the unreachable objects, and destroying them with compaction.</span></p><p class="c9"><span>Garbage collectors work on the concept of Garbage Collection Roots (</span><span class="c11">GC Roots</span><span class="c0">) to identify live and dead objects:</span></p><ul class="c8 lst-kix_m7pghtu66va-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Classes loaded by system class loader (not custom class loaders)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Live threads</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Local variables and parameters of the currently executing methods</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Local variables and parameters of JNI methods</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Global JNI reference</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Objects used as a monitor for synchronization</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Objects held from garbage collection by JVM for its purposes</span></li></ul><p class="c9"><span class="c0">The garbage collector traverses the whole object graph in memory, starting from those Garbage Collection Roots and following references from the roots to other objects.</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 234.67px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 234.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c0">A standard Garbage Collection implementation involves three phases:</span></p><ol class="c8 lst-kix_enlqsq9z2ad9-0 start" start="1"><li class="c9 c25 li-bullet-0"><span class="c0">Mark objects as alive - In this step, the GC identifies all the live objects in memory by traversing the object graph.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">Sweep dead objects - After marking phase, we have the memory space which is occupied by live (visited) and dead (unvisited) objects. The sweep phase releases the memory fragments which contain these dead objects.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Compact remaining objects in memory - The dead objects that were removed during the sweep phase may not necessarily be next to each other. Thus, you can end up having fragmented memory space. Memory can be compacted after the garbage collector deletes the dead objects, so that the remaining objects are in a contiguous block at the start of the heap. The compaction process makes it easier to allocate memory to new objects sequentially.</span></li></ol><p class="c9"><span class="c11">Generational Garbage Collection</span><span>: Having to mark and compact all the objects in a JVM is inefficient. As more and more objects are allocated, the list of objects grows, leading to longer garbage collection times. Empirical analysis of applications has shown that most objects in Java survive for only a short period of time (</span><span class="c11">Weak generational hypothesis</span><span class="c0">)</span></p><p class="c9"><span class="c0">Most of the garbage collector implementations distinguish between new objects and old objects, the &ldquo;young generation&rdquo; versus &ldquo;old generation&rdquo;. The goal is to make it cheaper for the programmer to create short-lived objects as they will be more quickly and efficiently disposed of to free up memory.</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 523.50px; height: 363.79px;"><img alt="" src="images/image13.png" style="width: 523.50px; height: 363.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c11">Young Generation</span><span>&nbsp;- Newly created objects start in the Young Generation. When objects are garbage collected from the Young Generation, it is a </span><span class="c11">minor garbage collection</span><span class="c0">&nbsp;event.</span></p><p class="c9"><span class="c11">Old Generation</span><span>&nbsp;- Objects that are long-lived are eventually moved from the Young Generation to the Old Generation. This is also known as Tenured Generation, and contains objects that have remained in the survivor spaces for a long time. When objects are garbage collected from the Old Generation, it is a </span><span class="c11">major garbage collection</span><span class="c0">&nbsp;event.</span></p><p class="c9"><span class="c11">Permanent Generation</span><span>&nbsp;(replaced with </span><span class="c11">MetaSpace</span><span class="c0">&nbsp;starting with Java 8) - Metadata such as classes and methods are stored in the Permanent Generation. It is populated by the JVM at runtime based on classes in use by the application. Classes that are no longer in use may be garbage collected from the Permanent Generation.</span></p><p class="c9"><span class="c0">Garbage Collectors are often benchmarked by:</span></p><ul class="c8 lst-kix_9r9qns1l7tou-0 start"><li class="c9 c25 li-bullet-0"><span class="c11">Max Stop-The-World Time</span><span class="c0">&nbsp;(Stop-The-World means that the execution of the program is suspended for GC) - The VM will adjust the java heap size and other GC-related parameters in an attempt to keep GC-induced pauses shorter than nnn milliseconds. (-XX:MaxGCPauseMillis=nnn)</span></li><li class="c9 c25 li-bullet-0"><span class="c11">Throughput</span><span class="c0">&nbsp;- GC aims to size the heap so that the time spent in garbage collection is below the ratio determined by the -XX:GCTimeRatio. For example -XX:GCTimeRatio=19 sets a goal of 5% of the total time for GC and throughput goal of 95%. That is, the application should get 19 times as much time as the collector.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">Heap Size</span><span class="c0">&nbsp;(memory footprint): -Xms and -Xmx</span></li></ul><p class="c9"><span class="c0">High load server-side apps generally seek short and predictable STW-time by means of server resources (HeapSize~RAM, Throughput~CPU).</span></p><h4 class="c26 c29" id="h.q16k3ghs70ri"><span class="c41">Serial Garbage Collector</span></h4><p class="c9"><span class="c0">Serial - This is the simplest GC implementation, as it basically works with a single thread. As a result, this GC implementation freezes all application threads when it runs. Hence, it is not a good idea to use it in multi-threaded applications like server environments.</span></p><p class="c9"><span class="c0">The Serial GC is the garbage collector of choice for most applications that do not have small pause time requirements and run on client-style machines. To enable Serial Garbage Collector, we can use the following argument:</span></p><a id="t.006349d50a4f754fe52723acee523b4822888b8d"></a><a id="t.0"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">java -XX:+UseSerialGC -jar Application.java</span></p></td></tr></table><h4 class="c29 c26" id="h.a5tfgcwsul6b"><span class="c41">Parallel Garbage Collector</span></h4><p class="c9"><span class="c0">It&#39;s the default GC of the JVM and sometimes called Throughput Collectors. Unlike Serial Garbage Collector, this uses multiple threads for managing heap space. But it also freezes other application threads while performing GC.</span></p><p class="c9"><span>If we use this GC, we can specify maximum garbage collection </span><span class="c11">threads</span><span>&nbsp;and </span><span class="c11">pause time</span><span>, </span><span class="c11">throughput</span><span>, and </span><span class="c11">footprint</span><span class="c0">&nbsp;(heap size):</span></p><a id="t.ef1446dc5f2084c4aed3803d7113188d697a86f6"></a><a id="t.1"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c16"><span class="c0">-XX:ParallelGCThreads=&lt;N&gt;</span></p><p class="c16"><span class="c0">-XX:MaxGCPauseMillis=&lt;N&gt;</span></p><p class="c16"><span class="c0">-XX:GCTimeRatio=&lt;N&gt;</span></p><p class="c16"><span class="c0">-Xmx&lt;N&gt;</span></p></td></tr></table><p class="c9"><span class="c0">To enable Parallel Garbage Collector, we can use the following argument:</span></p><a id="t.1f4a44744ae20ace1bdfe60d6dba3cde3ad9c0ab"></a><a id="t.2"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c16"><span class="c0">java -XX:+UseParallelGC -jar Application.java</span></p></td></tr></table><h4 class="c29 c26" id="h.dvyxh2ofc6u9"><span class="c41">CMS Garbage Collector</span></h4><p class="c9"><span class="c0">The Concurrent Mark Sweep (CMS) implementation uses multiple garbage collector threads for garbage collection. As of Java 9, the CMS garbage collector has been deprecated, Java 14 completely dropped the CMS support.</span></p><h4 class="c29 c26" id="h.53wry4k6q14o"><span class="c41">G1 Garbage Collector</span></h4><p class="c9"><span class="c0">G1 (Garbage First) Garbage Collector is designed for applications running on multi-processor machines with large memory space. It&#39;s available since JDK7 Update 4 and in later releases.</span></p><p class="c9"><span class="c0">G1 collector will replace the CMS collector since it&#39;s more performance efficient.</span></p><p class="c9"><span class="c0">Unlike other collectors, G1 collector partitions the heap into a set of equal-sized heap regions, each a contiguous range of virtual memory. When performing garbage collections, G1 shows a concurrent global marking phase (i.e. phase 1 known as Marking) to determine the liveness of objects throughout the heap.</span></p><p class="c9"><span class="c0">After the mark phase is completed, G1 knows which regions are mostly empty. It collects in these areas first, which usually yields a significant amount of free space (i.e. phase 2 known as Sweeping). It is why this method of garbage collection is called Garbage-First.</span></p><p class="c9"><span class="c0">To enable the G1 Garbage Collector, we can use the following argument:</span></p><a id="t.b74f47146bf0184d756541a8bf95c30d6f930010"></a><a id="t.3"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c16"><span>java -XX:+UseG1GC -jar Application.java</span></p></td></tr></table><h4 class="c29 c26" id="h.nzhrlty6nrw2"><span class="c41">Shenandoah Garbage Collector</span></h4><p class="c9"><span class="c0">Shenandoah is a low-latency garbage collector that enables Java applications to operate quickly without changes. The feature was first introduced upstream in JDK 12 and has since been backported to the long-term support JDK 11.</span></p><p class="c9"><span class="c0">Shenandoah&rsquo;s key advance over G1 is to do more of its garbage collection cycle work concurrently with the application threads. G1 can evacuate its heap regions, that is, move objects, only when the application is paused, while Shenandoah can relocate objects concurrently with the application. To achieve the concurrent relocation, it uses what&rsquo;s known as a Brooks pointer. This pointer is an additional field that each object in the Shenandoah heap has and which points back to the object itself.</span></p><p class="c9"><span class="c0">To use Shenandoah in your application from Java 12 onwards, enable it with the following options:</span></p><a id="t.f4159e22bfe841b9b1da956a953bd42b49d1ec06"></a><a id="t.4"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c16"><span class="c0">-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</span></p></td></tr></table><h4 class="c29 c26" id="h.n06ayh15lhza"><span class="c41">ZGC Garbage Collector</span></h4><p class="c9"><span class="c0">The Z Garbage Collector, also known as ZGC, is a scalable low latency garbage collector designed to meet the following goals:</span></p><ul class="c8 lst-kix_6y1ttbq1ogav-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Sub-millisecond max pause times</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Pause times do not increase with the heap, live-set or root-set size</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Handle heaps ranging from a 8MB to 16TB in size</span></li></ul><p class="c9"><span class="c0">At its core, ZGC is a concurrent garbage collector, meaning all heavy lifting work is done while Java threads continue to execute. This greatly limits the impact garbage collection will have on your application&#39;s response time.</span></p><p class="c9"><span class="c0">It is a region-based collector, which means that the heap is divided into smaller regions and the compaction efforts will be focused on a subset of those regions, the ones with the most garbage. It is a single generation collector, it does not have young or old generations, yet.</span></p><p class="c9"><span>One important thing to mention is that currently, pause times </span><span class="c11">do not increase with the heap or live size</span><span>, however, pause times </span><span class="c11">do increase with the root-set size</span><span class="c0">&nbsp;(number of java threads that your application is using).</span></p><p class="c9"><span>ZGC intends to provide stop-the-world phases as short as possible. It achieves it in such a way that the duration of these pause times doesn&#39;t increase with the heap size. </span><span class="c11">These characteristics make ZGC a good fit for server applications, where large heaps are common, and fast application response times are a requirement</span><span class="c0">.</span></p><p class="c9"><span class="c0">From JDK 15 in advance, you can use it just by specifying:</span></p><a id="t.83a5f1cf2c63fc3c543269229259505c05830c4f"></a><a id="t.5"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">-XX:+UseZGC</span></p></td></tr></table><h1 class="c42 c26" id="h.k1bj2or9nisv"><span class="c38">Data Types</span></h1><p class="c9"><span class="c0">Types in Java are divided into two categories&mdash;primitive types and reference types.</span></p><h2 class="c27 c26" id="h.cu021hq0bhf4"><span class="c13">Primitive Data Types</span></h2><a id="t.0fb72c24107bbc65f7ad16340106daa499d0d30b"></a><a id="t.6"></a><table class="c18"><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">Type</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">Description</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Wrapper class</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">byte</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">8-bit signed two&#39;s complement integer.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Byte</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">short</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">16-bit signed two&#39;s complement integer.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Short</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">int</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">32-bit signed two&#39;s complement integer.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Integer</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">long</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">64-bit two&#39;s complement integer.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Long</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">float</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">single-precision 32-bit IEEE 754 floating point.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Float</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">double</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">double-precision 64-bit IEEE 754 floating point.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Double</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">boolean</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">The boolean data type has only two possible values: true and false. Its &quot;size&quot; isn&#39;t something that&#39;s precisely defined.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Boolean</span></p></td></tr><tr class="c6"><td class="c52" colspan="1" rowspan="1"><p class="c14"><span class="c0">char</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c14"><span class="c0">16-bit Unicode character.</span></p></td><td class="c44" colspan="1" rowspan="1"><p class="c14"><span class="c0">Character</span></p></td></tr></table><p class="c9"><span class="c0">Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects. Sometimes you must use wrapper classes, for example when working with Collection objects, such as ArrayList, where primitive types cannot be used (the list can only store objects).</span></p><h2 class="c27 c26" id="h.6ir928h87wok"><span class="c13">Reference Data Types</span></h2><p class="c9"><span class="c50"><a class="c23" href="https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se15/preview/specs/class-terminology-jls.html&amp;sa=D&amp;source=editors&amp;ust=1657548985772958&amp;usg=AOvVaw0OSuyZDaAoTkBj33s6eFjQ">https://docs.oracle.com/javase/specs/jls/se15/preview/specs/class-terminology-jls.html</a></span><span class="c0">&nbsp;</span></p><p class="c9"><span>Reference types are the </span><span class="c11">class</span><span>&nbsp;types, the </span><span class="c11">interface</span><span>&nbsp;types, and the </span><span class="c11">array</span><span>&nbsp;types. An </span><span class="c11">enum</span><span>&nbsp;declaration is a kind of class declaration that introduces a special kind of class, an enum class. An </span><span class="c11">annotation</span><span class="c0">&nbsp;declaration is a kind of interface declaration that introduces a special kind of interface, an annotation interface.</span></p><p class="c9"><span class="c0">The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class Object, which is the (single) root of the class hierarchy.</span></p><a id="t.dade937e1c9f10b472a15ce901fc9ac87f3b8420"></a><a id="t.7"></a><table class="c18"><tr class="c34"><td class="c36" colspan="1" rowspan="1"><p class="c16"><span class="c11 c31">Class</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c16"><span class="c0">It is a set of instructions. It describes the content of the object.</span></p></td></tr><tr class="c6"><td class="c36" colspan="1" rowspan="1"><p class="c16"><span class="c31 c11">Array</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c16"><span class="c0">It provides the fixed-size data structure that stores the elements of the same type.</span></p></td></tr><tr class="c6"><td class="c36" colspan="1" rowspan="1"><p class="c16"><span class="c31 c11">Annotation</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c16"><span class="c0">It provides a way to associate metadata with program elements.</span></p></td></tr><tr class="c6"><td class="c36" colspan="1" rowspan="1"><p class="c16"><span class="c31 c11">Interface</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c16"><span class="c0">It is implemented by Java classes.</span></p></td></tr><tr class="c6"><td class="c36" colspan="1" rowspan="1"><p class="c16"><span class="c31 c11">Enumeration</span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c16"><span class="c0">It is a special kind of class that is type-safe. Each element inside the enum is an instance of that enum.</span></p></td></tr></table><p class="c9"><span>The </span><span class="c11">Object class</span><span class="c0">&nbsp;is the parent class of all the classes in java by default. In other words, it is the topmost class of java.</span></p><a id="t.e2e2d203f2e3864283261f6834da08c83f62c7ff"></a><a id="t.8"></a><table class="c18"><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">Object</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c0">clone()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Creates and returns a copy of this object.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">boolean</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">equals&#8203;(Object obj)</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Indicates whether some other object is &quot;equal to&quot; this one.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">void</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c0">finalize()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">The finalization mechanism is inherently problematic. Deprecated.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">Class&lt;?&gt;</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">getClass()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Returns the runtime class of this Object.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">int</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">hashCode()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span>Returns a hash code value for the object. By default, integer value is mostly derived from </span><span class="c11">memory address</span><span class="c0">&nbsp;of the object in heap (but it&rsquo;s not mandatory always)</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">void</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c0">notify()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Wakes up a single thread that is waiting on this object&#39;s monitor.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">void </span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c0">notifyAll()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Wakes up all threads that are waiting on this object&#39;s monitor.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">String</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">toString()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Returns a string representation of the object.</span></p></td></tr><tr class="c6"><td class="c24" colspan="1" rowspan="1"><p class="c14"><span class="c0">void</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c14"><span class="c0">wait()</span></p></td><td class="c45" colspan="1" rowspan="1"><p class="c14"><span class="c0">Causes the current thread to wait until it is awakened, typically by being notified or interrupted.</span></p></td></tr></table><p class="c9"><span class="c0">We can compare the reference types in Java. Java provides two ways to compare reference types:</span></p><ul class="c8 lst-kix_o5qrq9ipmu9v-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">By using the equal (==) operator - It compares the memory locations of the objects. If the memory address (reference) of both objects is the same, the objects are equal. Note that it does not compare the contents of the object.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">By using the Object.equals() Method - an equivalence relation on non-null object references:</span></li></ul><ul class="c8 lst-kix_o5qrq9ipmu9v-1 start"><li class="c2 li-bullet-0"><span>It is </span><span class="c11">reflexive</span><span class="c0">: for any non-null reference value x, x.equals(x) should return true.</span></li><li class="c2 li-bullet-0"><span>It is </span><span class="c11">symmetric</span><span class="c0">: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</span></li><li class="c2 li-bullet-0"><span>It is </span><span class="c11">transitive</span><span class="c0">: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</span></li><li class="c2 li-bullet-0"><span>It is </span><span class="c11">consistent</span><span class="c0">: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.</span></li><li class="c2 li-bullet-0"><span class="c0">For any non-null reference value x, x.equals(null) should return false.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li></ul><p class="c9"><span class="c31 c11">HashCode contract:</span></p><ul class="c8 lst-kix_q4pfpg5v40ry-0 start"><li class="c3 c25 li-bullet-0"><span class="c0">Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</span></li></ul><p class="c9"><span>In Java there are </span><span class="c11">four types of references</span><span class="c0">&nbsp;differentiated on the way by which they are garbage collected: Strong References, Weak References, Soft References, Phantom References.</span></p><h3 class="c20" id="h.3zwuem1pqyt5"><span class="c32">Strong references</span></h3><p class="c9"><span class="c0">This is the default type/class of Reference Object. Any object which has an active strong reference are not eligible for garbage collection. The object is garbage collected only when the variable which was strongly referenced points to null.</span></p><a id="t.d4c1fea4bf290946961e9b051fbf8ceb3d3f229d"></a><a id="t.9"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c16"><span class="c0">MyClass obj = new MyClass ();</span></p></td></tr></table><h3 class="c20" id="h.bdha5rlh614h"><span class="c32">Weak references</span></h3><p class="c9"><span class="c0">Suppose that the garbage collector determines at a certain point in time that an object is weakly reachable. At that time it will atomically clear all weak references to that object and all weak references to any other weakly-reachable objects from which that object is reachable through a chain of strong and soft references.</span></p><a id="t.ec3ec85fd25e7edeb0be9250b1d700f7e9ae7b3c"></a><a id="t.10"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Object o = new Object();</span></p><p class="c14"><span class="c0">WeakReference&lt;Object&gt; objectWeakReference = new WeakReference&lt;&gt;(o);</span></p><p class="c14"><span class="c0">o = null;</span></p></td></tr></table><p class="c9"><span class="c0">This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</span></p><h3 class="c20" id="h.l58ug3igqiv2"><span class="c32">Soft references</span></h3><p class="c9"><span class="c0">In Soft reference, even if the object is free for garbage collection then also it is not garbage collected, until JVM is in need of memory badly. Softly referenced objects are collected as a last resort before an OutOfMemoryError is thrown. You can quite easily build a very simple and efficient cache using this type of reference.</span></p><a id="t.1c575c9f33c1f7e29fff4b5a2d44e98cd7dd0847"></a><a id="t.11"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Object o = new Object();</span></p><p class="c14"><span class="c0">SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o);</span></p><p class="c14"><span class="c0">o = null;</span></p></td></tr></table><p class="c9"><span>&ldquo;</span><span class="c55">All soft references to softly-reachable objects are guaranteed to have been freed before the virtual machine throws an OutOfMemoryError</span><span>&rdquo; - </span><span class="c11">that&rsquo;s a lie</span><span class="c0">. It was true when soft references were first introduced in java 1.2, but from java 1.3.1 the jvm property -XX:SoftRefLRUPolicyMSPerMB was introduced. It defaults to 1000 (milliseconds), meaning that if there&rsquo;s only 10MB available heap, the garbage collector will free references that have been used more than 10s ago. I.e. everything else will not be freed, leading to an OutOfMemoryError, breaking the guarantee from the javadoc. No problem, let&rsquo;s just set it to -XX:SoftRefLRUPolicyMSPerMB=0 and the javadoc is suddenly true again.</span></p><p class="c9"><span>When the GC figures that memory is running low and it better frees some softly referenced objects, </span><span class="c11">it will free all of them</span><span class="c0">. This will make our cache very inefficient, because it&rsquo;s expensive to recreate those objects. It would be better if the GC would only free a small portion of the available soft references.</span></p><h3 class="c20" id="h.u2ecmnv25o62"><span class="c32">Phantom references</span></h3><p class="c9"><span class="c0">The objects which are being referenced by phantom references are eligible for garbage collection. But, before removing them from the memory, JVM puts them in a queue called &lsquo;reference queue</span></p><a id="t.cc93667096fcd5d2c965ec9f903762d8639080de"></a><a id="t.12"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c16"><span class="c0">Object o = new Object();</span></p><p class="c16"><span class="c0">ReferenceQueue&lt;Object&gt; refQueue = new ReferenceQueue&lt;&gt;();</span></p><p class="c16"><span class="c0">PhantomReference&lt;Object&gt; ref = new PhantomReference&lt;&gt;(o, refQueue);</span></p><p class="c16"><span class="c0">o = null;</span></p></td></tr></table><h3 class="c20" id="h.re9p466rm724"><span class="c32">Arrays</span></h3><p class="c9"><span class="c0">In the Java programming language, arrays are objects, are dynamically created, and may be assigned to variables of type Object. All methods of class Object may be invoked on an array.</span></p><p class="c9"><span class="c0">Array stores a fixed-size sequential collection of elements of the same type. It can contain primitives (int, char, etc.) as well as object (or non-primitive) references of a class depending on the definition of the array. In case of primitive data types, the actual values are stored in contiguous memory locations. In case of objects of a class, the actual objects are stored in heap segment.</span></p><p class="c9"><span class="c0">Some other properties:</span></p><ul class="c8 lst-kix_k5sh93b5y13o-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">In Java all arrays are dynamically allocated.(discussed below)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Since arrays are objects in Java, we can find their length using the object property length. This is different from C/C++ where we find length using sizeof.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A Java array variable can also be declared like other variables with [] after the data type.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The variables in the array are ordered and each have an index beginning from 0.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Java array can also be used as a static field, a local variable or a method parameter.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The size of an array must be specified by an int or short value and not long.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The direct superclass of an array type is Object.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Every array type implements the interfaces Cloneable and java.io.Serializable.</span></li></ul><p class="c9"><span class="c0">Java array object uses default (Object) implementation for hashcode() and equals() methods:</span></p><ul class="c8 lst-kix_b4zwlds6f31w-0 start"><li class="c9 c25 li-bullet-0"><span class="c11">equals</span><span>(Object obj): a method provided by java.lang.Object that indicates whether some other object passed as an argument is &quot;equal to&quot; the current instance. The default implementation provided by the JDK is based on memory location &mdash; two objects are equal if and only if they are stored in the </span><span class="c11">same memory address</span><span class="c0">.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">hashcode</span><span>(): a method provided by java.lang.Object that returns an integer representation of the object memory address. By default, this method returns a </span><span class="c11">random integer</span><span class="c0">&nbsp;that is unique for each instance. This integer might change between several executions of the application and won&#39;t stay the same.</span></li></ul><p class="c9"><span class="c31 c11">It is important to notice here that neither equals nor hashcode methods called on an array object reflect the inner state (content) of the array.</span></p><p class="c9"><span>The </span><span class="c11">java.util.Arrays</span><span class="c0">&nbsp;class contains various static methods for sorting and searching arrays, comparing arrays, and filling array elements. These methods are overloaded for all primitive types.</span></p><p class="c9"><span class="c0">Some examples:</span></p><a id="t.b20f0293dab518fb682f63b175ab9e95e1e795fd"></a><a id="t.13"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">int[] arr = {1,2,3};</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);</span></p><p class="c14"><span class="c0">int[] copy = Arrays.copyOf(arr, arr.length);</span></p><p class="c14"><span class="c0">//Compares two int arrays lexicographically:</span></p><p class="c14"><span class="c0">int compareResult = Arrays.compare(arr, new int[]{1, 2, 3});</span></p><p class="c14"><span class="c0">boolean equals = Arrays.equals(arr, new int[]{1, 2, 3});</span></p><p class="c14"><span class="c0">int searchResult = Arrays.binarySearch(arr, 2);</span></p><p class="c14"><span class="c0">int hashCode = Arrays.hashCode(arr);</span></p><p class="c14"><span class="c0">IntStream stream = Arrays.stream(arr);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">Arrays.fill(arr, 0);</span></p><p class="c14"><span class="c0">Arrays.sort(arr);</span></p></td></tr></table><h1 class="c42 c26" id="h.kymipayaph1d"><span class="c38">Java OOP</span></h1><p class="c9"><span class="c0">OOP stands for Object-Oriented Programming.</span></p><p class="c9"><span>Procedural programming is about writing procedures or methods that perform operations on the data, while object-oriented programming is about </span><span class="c11">creating objects that contain both data and methods</span><span class="c0">.</span></p><p class="c9"><span class="c0">Object-oriented programming has several advantages over procedural programming:</span></p><ul class="c8 lst-kix_1vd5g4tj2m3r-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">OOP is faster and easier to execute</span></li><li class="c9 c25 li-bullet-0"><span class="c0">OOP provides a clear structure for the programs</span></li><li class="c9 c25 li-bullet-0"><span class="c0">OOP helps to keep the Java code DRY &quot;Don&#39;t Repeat Yourself&quot;, and makes the code easier to maintain, modify and debug</span></li><li class="c9 c25 li-bullet-0"><span class="c0">OOP makes it possible to create full reusable applications with less code and shorter development time</span></li></ul><p class="c9"><span class="c0">There are four main OOP concepts in Java.</span></p><h3 class="c20" id="h.815rcraha9w6"><span class="c32">Abstraction</span></h3><p class="c9"><span class="c11">Abstraction</span><span class="c0">&nbsp;means using simple things to represent complexity. We all know how to turn the TV on, but we don&rsquo;t need to know how it works in order to enjoy it. In Java, abstraction means simple things like objects, classes, and variables represent more complex underlying code and data. This is important because it lets avoid repeating the same work multiple times.</span></p><p class="c9"><span>Data abstraction is the process of hiding certain details and showing only essential information to the user. Abstraction can be achieved with either </span><span class="c11">abstract classes</span><span>&nbsp;or </span><span class="c11">interfaces</span><span class="c0">.</span></p><p class="c9"><span class="c0">The abstract keyword is a non-access modifier, used for classes and methods:</span></p><ul class="c8 lst-kix_1uiq9wd1knsy-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).</span></li></ul><p class="c9"><span class="c11">Difference Between Interface and Abstract Class:</span></p><ul class="c8 lst-kix_fxxo4x7dhkhu-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Type of methods: Interface can have only abstract methods. An abstract class can have abstract and non-abstract methods. From Java 8, it can have default and static methods also.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Final Variables: Variables declared in a Java interface are by default final. An abstract class may contain non-final variables.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Type of variables: Abstract class can have final, non-final, static and non-static variables. The interface has only static and final variables.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Implementation: Abstract class can provide the implementation of the interface. Interface can&rsquo;t provide the implementation of an abstract class.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Inheritance vs Abstraction: A Java interface can be implemented using the keyword &ldquo;implements&rdquo; and an abstract class can be extended using the keyword &ldquo;extends&rdquo;.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Multiple implementations: An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java interfaces.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Accessibility of Data Members: Members of a Java interface are public by default. A Java abstract class can have class members like private, protected, etc. </span></li></ul><p class="c9"><span>Interface can provide default implementation using default methods which enable you to add new functionality to existing interfaces and </span><span class="c11">ensure binary compatibility</span><span class="c0">&nbsp;with code written for older versions of those interfaces. In particular, default methods enable you to add methods that accept lambda expressions as parameters to existing interfaces.</span></p><h3 class="c26 c59" id="h.pxsjwu5ph3hx"><span class="c32">Encapsulation</span></h3><p class="c3"><span class="c11">Encapsulation</span><span class="c0">&nbsp;is the practice of keeping fields within a class private, then providing access to them via public methods. It&rsquo;s a protective barrier that keeps the data and code safe within the class itself. This way, we can reuse objects like code components or variables without allowing open access to the data system-wide.</span></p><p class="c3"><span class="c0">Advantages of Encapsulation: &nbsp;</span></p><ul class="c8 lst-kix_jmpizlww91eb-0 start"><li class="c3 c25 li-bullet-0"><span class="c0">Data Hiding: The user will have no idea about the inner implementation of the class. It will not be visible to the user how the class is storing values in the variables. The user will only know that we are passing the values to a setter method and variables are getting initialized with that value.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">Increased Flexibility: We can make the variables of the class as read-only or write-know that only depending on our requirement. If we wish to make the variables read-only then we have to omit the setter methods like setName(), setAge(), etc. from the above program or if we wish to make the variables as write-only then we have to omit the get methods like getName(), getAge(), etc. from the above program.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">Reusability: Encapsulation also improves the re-usability and ease of change with new requirements.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">Testing code is easy: Encapsulated code is easy to test for unit testing.</span></li></ul><p class="c3"><span class="c0">Java provides a number of access modifiers to set access levels for classes, variables, methods, and constructors. The four access levels are:</span></p><ul class="c8 lst-kix_asj4vxxj20d3-0 start"><li class="c3 c25 li-bullet-0"><span>Visible to the class only (</span><span class="c11">private</span><span class="c0">).</span></li><li class="c3 c25 li-bullet-0"><span>Visible to the package, the </span><span class="c11">default</span><span class="c0">. No modifiers are needed.</span></li><li class="c3 c25 li-bullet-0"><span>Visible to the package and all subclasses (</span><span class="c11">protected</span><span class="c0">).</span></li><li class="c3 c25 li-bullet-0"><span>Visible to the world (</span><span class="c11">public</span><span class="c0">).</span></li></ul><a id="t.3aaa9acec95d4c5731dc7ea1fb8bade5b912e496"></a><a id="t.14"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c16 c35"><span class="c0"></span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">within class</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">within package</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">outside package by subclass</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">outside package</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">Private</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c3"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">N</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">N</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">N</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">Default</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">N</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">N</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">Protected</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">N</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c16"><span class="c0">Public</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Y</span></p></td></tr></table><h3 class="c26 c57" id="h.j8q5tb3yve30"><span class="c32">Inheritance</span></h3><p class="c3"><span class="c11">Inheritance</span><span class="c0">&nbsp;lets programmers create new classes that share some of the attributes of existing classes. This lets us build on previous work without reinventing the wheel.</span></p><p class="c3"><span class="c0">A Java class can only extend one parent class. Multiple inheritance is not allowed. Interfaces are not classes, however, and an interface can extend more than one parent interface. The extends keyword is used once, and the parent interfaces are declared in a comma-separated list.</span></p><p class="c3"><span class="c31 c11">Why is multiple inheritance for classes not allowed?</span></p><p class="c3"><span>The &quot;</span><span class="c11">diamond problem</span><span class="c0">&quot; is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 116.02px; height: 173.23px;"><img alt="" src="images/image15.png" style="width: 116.02px; height: 173.23px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span>Before Java 8, interfaces could have only abstract methods. The implementation of these methods has to be provided in a separate class. So, if a new method is to be added in an interface, then its implementation code has to be provided in the class implementing the same interface. To overcome this issue, Java 8 has introduced the concept of </span><span class="c11">default methods</span><span class="c0">&nbsp;which allow the interfaces to have methods with implementation without affecting the classes that implement the interface.</span></p><p class="c3"><span>The default methods were introduced to provide </span><span class="c11">backward compatibility</span><span class="c0">&nbsp;so that existing interfaces can use the lambda expressions without implementing the methods in the implementation class. Default methods are also known as defender methods or virtual extension methods.</span></p><p class="c3"><span class="c11">Until you don&#39;t create ambiguity by using default methods on interfaces, you are fine to use it</span><span>. If it creates ambiguity, the compiler will alert you by throwing a compile-time error &quot;inherits unrelated defaults&quot;. In case both the implemented interfaces contain default methods with the same method signature, the implementing class should </span><span class="c11">explicitly specify which default method</span><span class="c0">&nbsp;is to be used or it should override the default method.</span></p><a id="t.f9d45e06eefa7543d35b140b77ffa562073fbb44"></a><a id="t.15"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public class Clazz implements IFace, IFace2 {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; @Override</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public int dom(int a) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return IFace.super.dom(a);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public interface IFace {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; default int dom(int a) { return 1;}</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public interface IFace2 {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; default int dom(int a) {return 0; };</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><h3 class="c20" id="h.y4594oc1oeq9"><span class="c32">Polymorphism</span></h3><p class="c9"><span>The dictionary definition of </span><span class="c11">polymorphism</span><span class="c0">&nbsp;refers to a principle in biology in which an organism or species can have many different forms or stages. This principle can also be applied to object-oriented programming and languages like the Java language. Subclasses of a class can define their own unique behaviors and yet share some of the same functionality of the parent class.</span></p><h4 class="c29 c26" id="h.71ce8yyblktk"><span class="c41">Class Casting</span></h4><p class="c9"><span class="c0">Casting does not change the actual object type. Only the reference type gets changed.</span></p><p class="c9"><span>If the reference variable of Parent class refers to the object of Child class, it is known as </span><span class="c11">upcasting</span><span class="c0">. Upcasting is always allowed, because the reference object of a subtype is always compatible with a supertype. Upcasting can be done implicitly.</span></p><p class="c54"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 346.50px; height: 179.61px;"><img alt="" src="images/image7.png" style="width: 346.50px; height: 179.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c0">Example:</span></p><a id="t.298296f056cce936e6622841ad02b942e182de85"></a><a id="t.16"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">class A{} &nbsp;</span></p><p class="c14"><span class="c0">class B extends A{} &nbsp;</span></p><p class="c14"><span class="c0">A a=new B();//upcasting &nbsp;</span></p></td></tr></table><p class="c9"><span class="c11">Downcasting</span><span class="c0">&nbsp;is casting to a subtype, downward to the inheritance tree. Example:</span></p><a id="t.ba89f0bb703cc010f4eee918ebe1d5bc218a04e8"></a><a id="t.17"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Object o = getSomeObject(),</span></p><p class="c14"><span class="c0">String s = (String) o; // this is allowed because o could reference a String</span></p></td></tr></table><p class="c9"><span>The Java language provides the </span><span class="c11">instanceof</span><span class="c0">&nbsp;keyword to check the type of an object before casting. For example:</span></p><a id="t.6920e1c6ea5bd7b9f1df487c10efa8f2c07a3562"></a><a id="t.18"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">if (anim instanceof Cat) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; Cat cat = (Cat) anim;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; cat.meow();</span></p><p class="c14"><span class="c0">} else if (anim instanceof Dog) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; Dog dog = (Dog) anim;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; dog.bark();</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">So if you are not sure about the original object type, use the instanceof operator to check the type before casting. This eliminates the risk of a ClassCastException thrown.</span></p><p class="c9"><span class="c0">There&#39;s also another way to cast objects using the methods of Class:</span></p><a id="t.245329846168cb9dedbdbdba2a02fc4b858bfc8b"></a><a id="t.19"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public void whenDowncastToCatWithCastMethod_thenMeowIsCalled() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; Animal animal = new Cat();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; if (Cat.class.isInstance(animal)) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Cat cat = Cat.class.cast(animal);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cat.meow();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><h4 class="c29 c26" id="h.iuix14k02sc7"><span class="c41">Compile-time vs Runtime polymorphism</span></h4><p class="c9"><span class="c0">There are two types of polymorphism in Java: compile-time polymorphism and runtime polymorphism.</span></p><p class="c9"><span class="c11">Compile-time polymorphism</span><span>&nbsp;is also known as static polymorphism. It is achieved by method overloading (or operator overloading, but Java doesn&rsquo;t support the Operator Overloading). In </span><span class="c11">method overloading</span><span class="c0">, a single method may perform different functions depending on the context in which it&rsquo;s called. That is, a single method name might work in different ways depending on what arguments are passed to it.</span></p><a id="t.8ab8eca9f7fb96354e4e9f3f199f51d1b136240e"></a><a id="t.20"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void overloadingTest() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; BaseClass baseClass = new BaseClass();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(baseClass.method1(&quot;1&quot;));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(baseClass.method1((Object) &quot;2&quot;));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(baseClass.method1(new String[] {&quot;3&quot;}));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(baseClass.method1(new Object[] {&quot;4&quot;}));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; </span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public static class BaseClass {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public String method1(String arg) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &quot;String:&quot; + arg;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public String method1(String ... args) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &quot;String ... args:&quot; + Arrays.stream(args)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.joining());</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public String method1(Object arg) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &quot;Object arg:&quot; + arg.toString();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public String method1(Object ... args) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &quot;Object ... args:&quot; + Arrays.stream(args)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(Object::toString)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.joining());</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span class="c0">Output:</span></p><a id="t.bc13b54c6a63164a54cf731d5d7ebbde0976c7ce"></a><a id="t.21"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">String:1</span></p><p class="c14"><span class="c0">Object arg:2</span></p><p class="c14"><span class="c0">String ... args:3</span></p><p class="c14"><span class="c0">Object ... args:4</span></p></td></tr></table><p class="c9"><span class="c11">Runtime polymorphism</span><span>&nbsp;is also known as Dynamic Method Dispatch. It is a process in which a function call to the overridden method is resolved at Runtime. This type of polymorphism is achieved by </span><span class="c11">method Overriding</span><span class="c0">. It occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden.</span></p><a id="t.7a7f03767d54b402f8d3fd518f008140e439e88c"></a><a id="t.22"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void overridingTest() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Parent cls = new Child();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cls.say();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;Obtaining var externally: &quot; + cls.var);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;Obtaining var externally using overriding: &quot; + cls.getVar());</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public static class Parent {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public int var = 0;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void say() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;I&#39;m parent, var=&quot; + var);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public int getVar() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return var;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public static class Child extends Parent {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public int var = 1;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void say() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;I&#39;m child, var=&quot; + var);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; @Override</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public int getVar() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return var; //we could access the parent var using super.var</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span class="c11">Hiding Fields</span><span class="c0">: Within a class, a field that has the same name as a field in the superclass hides the superclass&#39;s field, even if their types are different. Within the subclass, the field in the superclass cannot be referenced by its simple name. Instead, the field must be accessed through super, which is covered in the next section. Generally speaking, we don&#39;t recommend hiding fields as it makes code difficult to read.</span></p><p class="c9"><span class="c31 c11">Java polymorphism from the C++ point of view: </span></p><p class="c9"><span>By default, all the instance methods in Java are considered as the </span><span class="c11">Virtual function</span><span class="c0">&nbsp;except final, static, and private methods as these methods can be used to achieve polymorphism.</span></p><p class="c9"><span class="c0">The virtual keyword is not used in Java to define the virtual function; instead, the virtual functions and methods are achieved using the following techniques:</span></p><ul class="c8 lst-kix_8vndm4gbn4ci-0 start"><li class="c9 c25 li-bullet-0"><span>We can override the virtual function with the inheriting class function using the </span><span class="c11">same function name</span><span class="c0">. Generally, the virtual function is defined in the parent class and override it in the inherited class.</span></li><li class="c9 c25 li-bullet-0"><span>The virtual function is supposed to be defined in the derived class. We can call it by referring to the derived class&#39;s object using the reference or </span><span class="c11">pointer of the base class</span><span class="c0">.</span></li><li class="c9 c25 li-bullet-0"><span>A virtual function </span><span class="c11">should have the same name and parameters (method signature) in the base and derived class</span><span class="c0">.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">For the virtual function, an IS-A relationship is necessary, which is used to define the class hierarchy in inheritance.</span></li><li class="c9 c25 li-bullet-0"><span>The Virtual function </span><span class="c11">cannot be private</span><span class="c0">, as the private functions cannot be overridden.</span></li><li class="c9 c25 li-bullet-0"><span>A virtual function or method also </span><span class="c11">cannot be final</span><span class="c0">, as the final methods also cannot be overridden.</span></li><li class="c9 c25 li-bullet-0"><span>Static functions are also cannot be overridden; so, a virtual function </span><span class="c11">should not be static</span><span class="c0">.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">By default, Every non-static method in Java is a virtual function.</span></li><li class="c9 c25 li-bullet-0"><span>The virtual functions can be used to achieve oops concepts like </span><span class="c11">runtime polymorphism</span><span class="c0">.</span></li></ul><p class="c9"><span class="c11">Static, private, and final methods and variables are resolved using static binding which makes their execution fast because no time is wasted to find the correct method during runtime</span><span class="c0">.</span></p><h3 class="c20" id="h.jbeo3nf5ene5"><span class="c32">Final</span></h3><p class="c9"><span class="c0">While inheritance enables us to reuse existing code, sometimes we do need to set limitations on extensibility for various reasons; the final keyword allows us to do exactly that:</span></p><ul class="c8 lst-kix_caf22lmip6rs-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Classes marked as final can&rsquo;t be extended</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Methods marked as final cannot be overridden</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Variables marked as final can&#39;t be reassigned</span></li></ul><h3 class="c20" id="h.y2mdk9fpsl9a"><span class="c32">Static</span></h3><p class="c9"><span>The </span><span class="c11">static variable</span><span class="c0">&nbsp;can be used to refer to the common property of all objects (which is not unique for each object), for example, the company name of employees, college name of students, etc.</span></p><p class="c9"><span class="c0">The static variable gets memory only once in the class area at the time of class loading. It makes your program memory efficient (i.e., it saves memory)</span></p><p class="c9"><span>If you apply a </span><span class="c11">static</span><span>&nbsp;keyword with any method, it is known as a </span><span class="c11">static method</span><span class="c0">.</span></p><ul class="c8 lst-kix_junjfpk3lk1m-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">A static method belongs to the class rather than the object of a class.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A static method can be invoked without the need for creating an instance of a class.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A static method can access static data member and can change the value of it.</span></li></ul><p class="c9"><span class="c11">Why is the Java main method static?</span><span class="c0">&nbsp;It is because the object is not required to call a static method. If the main() is allowed to be non-static, then while calling the main() method JVM has to instantiate its class. While instantiating it has to call the constructor of that class, There will be ambiguity if the constructor of that class takes an argument.</span></p><p class="c9"><span class="c0">The main() method in Java must be declared public, static and void. If any of these are missing, the Java program will compile but a runtime error will be thrown.</span></p><h3 class="c20" id="h.p3ciqssm30p"><span class="c32">Initialization order</span></h3><ol class="c8 lst-kix_7aani3dcd0w3-0 start" start="1"><li class="c9 c25 li-bullet-0"><span class="c0">Static fields and static blocks of ancestors. In each class they are initialized in order of appearance.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Static fields and static block of instantiated class.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Instance fields and initialization blocks of ancestors. In each class they are initialized in order of appearance.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Constructor of ancestor after initialization of its instance fields.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Instance fields and initialization blocks of the current class. Also in order of appearance.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Constructor of the current class.</span></li></ol><a id="t.20f2010cafaee15c9f65291f97c27cd94d34d546"></a><a id="t.23"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public class InitOrder {</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; //Print message and return given object</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; static &lt;T&gt; T init(String name, T object) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.printf(&quot;Initializing &#39;%s&#39; to &#39;%s&#39;%n&quot;, name, object);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return object;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; static class Base {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private int i = init(&quot;Base instance i&quot;, 5);</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private static int x = init(&quot;Base static x&quot;, 1);</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private int ctorI;</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public Base() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctorI = init(&quot;Base ctorI&quot;, 7);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private static int y = init(&quot;Base static y&quot;, 2);</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; { // instance initialization block</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = init(&quot;Base instance block j&quot;, 6);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private static int z;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; static { // static initialization block:</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; z = init(&quot;Base.z static block&quot;, 3);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private int j;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; static class Subclass extends Base {</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public Subclass() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctorB = init(&quot;Subclass ctorB&quot;, 9);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int ctorB;</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int a = init(&quot;Subclass instance a&quot;, 8);</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; static int foo = init(&quot;Subclass static foo&quot;, 4);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public static void main(String[] args) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;First Subclass instance:&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Base base = new Subclass();</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;Another Subclass instance:&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; base = new Subclass();</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;Instance of Base:&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; base = new Base();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span class="c0">Output:</span></p><a id="t.538a5067d09abdb014c152d4b8a940a212b5a527"></a><a id="t.24"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">First Subclass instance:</span></p><p class="c14"><span class="c0">Initializing &#39;Base static x&#39; to &#39;1&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base static y&#39; to &#39;2&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base.z static block&#39; to &#39;3&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Subclass static foo&#39; to &#39;4&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base instance i&#39; to &#39;5&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base instance block j&#39; to &#39;6&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base ctorI&#39; to &#39;7&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Subclass instance a&#39; to &#39;8&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Subclass ctorB&#39; to &#39;9&#39;</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">Another Subclass instance:</span></p><p class="c14"><span class="c0">Initializing &#39;Base instance i&#39; to &#39;5&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base instance block j&#39; to &#39;6&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base ctorI&#39; to &#39;7&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Subclass instance a&#39; to &#39;8&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Subclass ctorB&#39; to &#39;9&#39;</span></p><p class="c14"><span class="c0">&nbsp;</span></p><p class="c14"><span class="c0">Instance of Base:</span></p><p class="c14"><span class="c0">Initializing &#39;Base instance i&#39; to &#39;5&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base instance block j&#39; to &#39;6&#39;</span></p><p class="c14"><span class="c0">Initializing &#39;Base ctorI&#39; to &#39;7&#39;</span></p></td></tr></table><h3 class="c20" id="h.gwbo50rboqkb"><span class="c32">Composition vs Inheritance</span></h3><p class="c9"><span>One of the advantages of an Object-Oriented programming language is code reuse. There are two ways we can do code reuse either by the implementation of </span><span class="c11">inheritance</span><span>&nbsp;(IS-A relationship), or object </span><span class="c11">composition</span><span class="c0">&nbsp;(HAS-A relationship). Although the compiler and Java virtual machine (JVM) will do a lot of work for you when you use inheritance, you can also get at the functionality of inheritance when you use composition.</span></p><p class="c9"><span>In object-oriented programming, the concept of IS-A is a totally based on Inheritance, which can be of two types Class Inheritance or Interface Inheritance. It is just like saying &quot;A is a B type of thing&quot;. For example, Apple is a Fruit, Car is a Vehicle etc. Inheritance is </span><span class="c11">unidirectional</span><span class="c0">. For example, House is a Building. But Building is not a House.</span></p><p class="c9"><span>It is a key point to note that you can easily identify the IS-A relationship. Wherever you see an </span><span class="c11">extends</span><span>&nbsp;keyword or </span><span class="c11">implements</span><span class="c0">&nbsp;keyword in a class declaration, then this class is said to have IS-A relationship.</span></p><p class="c9"><span class="c0">Composition(HAS-A) simply mean the use of instance variables that are references to other objects. For example Maruti has Engine, or House has Bathroom.</span></p><p class="c9"><span class="c0">Comparing Composition and Inheritance:</span></p><ul class="c8 lst-kix_j7pwumu6gnqz-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">It is easier to change the class implementing composition than inheritance. The change of a superclass impacts the inheritance hierarchy to subclasses.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">You can&#39;t add to a subclass a method with the same signature but a different return type as a method inherited from a superclass. Composition, on the other hand, allows you to change the interface of a front-end class without affecting back-end classes.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Composition is dynamic binding (run-time binding) while Inheritance is static binding (compile time binding)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">It is easier to add new subclasses (inheritance) than it is to add new front-end classes (composition) because inheritance comes with polymorphism. If you have a bit of code that relies only on a superclass interface, that code can work with a new subclass without change. This is not true of composition unless you use composition with interfaces. Used together, composition and interfaces make a very powerful design tool.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">With both composition and inheritance, changing the implementation (not the interface) of any class is easy. The ripple effect of implementation changes remains inside the same class.</span></li></ul><ul class="c8 lst-kix_j7pwumu6gnqz-1 start"><li class="c9 c37 li-bullet-0"><span class="c0">Don&#39;t use inheritance just to get code reuse If all you really want is to reuse code and there is no is-a relationship in sight, use composition.</span></li><li class="c9 c37 li-bullet-0"><span class="c0">Don&#39;t use inheritance just to get at polymorphism If all you really want is a polymorphism, but there is no natural is-a relationship, use composition with interfaces.</span></li></ul><p class="c9"><span class="c0">A good example of composition is Strategy Pattern:</span></p><a id="t.95f351cdc4a5cafd18cddc818398ace4bfc2c78e"></a><a id="t.25"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public interface Flyable{</span></p><p class="c14"><span class="c0">&nbsp;public void fly();</span></p><p class="c14"><span class="c0">}</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">public class Duck {</span></p><p class="c14"><span class="c0">&nbsp;Flyable fly;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp;public Duck(){</span></p><p class="c14"><span class="c0">&nbsp; fly = new BackwardFlying();</span></p><p class="c14"><span class="c0">&nbsp;}</span></p><p class="c14"><span class="c0">}</span></p><p class="c14"><span class="c0">Thus we can have multiple classes which implement flying eg:</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">public class BackwardFlying implements Flyable{</span></p><p class="c14"><span class="c0">&nbsp; public void fly(){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; Systemout.println(&quot;Flies backward &quot;);</span></p><p class="c14"><span class="c0">&nbsp; }</span></p><p class="c14"><span class="c0">}</span></p><p class="c14"><span class="c0">public class FastFlying implements Flyable{</span></p><p class="c14"><span class="c0">&nbsp; public void fly(){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; Systemout.println(&quot;Flies 100 miles/sec&quot;);</span></p><p class="c14"><span class="c0">&nbsp; }</span></p><p class="c14"><span class="c0">}</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span>To favor composition over inheritance is a design principle that gives the design </span><span class="c11">higher flexibility</span><span>. </span><span class="c11">It is more natural to build business-domain classes out of various components than trying to find commonality between them and creating a family tree</span><span>. For example, an accelerator pedal and a steering wheel share very few common traits, yet both are vital components in a car. What they can do and how they can be used to benefit the car is easily defined. Composition also provides a more stable business domain in the long term as it is less prone to the quirks of the family members. In other words, </span><span class="c11">it is better to compose what an object can do (HAS-A) than extend what it is (IS-A)</span><span class="c0">.</span></p><p class="c9"><span>Initial design is simplified by identifying system object behaviors in separate interfaces instead of creating a hierarchical relationship to distribute behaviors among business-domain classes via inheritance. </span><span class="c11">This approach more easily accommodates future requirements changes that would otherwise require a complete restructuring of business-domain classes in the inheritance model</span><span>. Additionally, it avoids problems often associated with relatively minor changes to an inheritance-based model that includes several generations of classes. </span><span class="c11">Composition relation is more flexible as it may be changed on runtime</span><span class="c0">, while sub-typing relations are static and need recompilation in many languages.</span></p><p class="c9"><span class="c0">Some languages, notably Go, use type composition exclusively.</span></p><h3 class="c20" id="h.wkn9iloqgzay"><span class="c32">Nested classes</span></h3><p class="c9"><span class="c0">The Java programming language allows you to define a class within another class. Such a class is called a nested class. Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.</span></p><a id="t.8aa54b2a2b9c318711a3b8ce3a0a1fbd50eecf83"></a><a id="t.26"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">class OuterClass {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; ...</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; static class StaticNestedClass {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ...</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; class InnerClass {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ...</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span>A nested class is a member of its enclosing class. </span><span class="c11">As a member of the OuterClass, a nested class can be declared private, public, protected, or package private</span><span>. (Recall that </span><span class="c11">outer classes can only be declared public or package private</span><span class="c0">.)</span></p><p class="c9"><span>Non-static nested classes (inner classes) have </span><span class="c11">direct access to other members of the enclosing class</span><span>, even if they are declared private. Also, because an inner class is associated with an instance, </span><span class="c11">it cannot define any static members itself</span><span>. A good example of utilizing Java inner class is a </span><span class="c11">Builder</span><span class="c0">&nbsp;pattern.</span></p><p class="c9"><span class="c0">Static nested classes do not have access to other members of the enclosing class. </span></p><p class="c9"><span class="c0">Why Use Nested Classes?</span></p><ul class="c8 lst-kix_8vi5oc8p4pg0-0 start"><li class="c9 c25 li-bullet-0"><span class="c11">It is a way of logically grouping classes that are only used in one place</span><span class="c0">: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such &quot;helper classes&quot; makes their package more streamlined.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">It increases encapsulation</span><span class="c0">: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A&#39;s members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">It can lead to more readable and maintainable code</span><span class="c0">: Nesting small classes within top-level classes places the code closer to where it is used.</span></li></ul><p class="c9"><span class="c0">Playing with nested classes:</span></p><a id="t.de9760850dc7b9539a254f8f56c945b9af80927a"></a><a id="t.27"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public class NestedClassTest {</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public int outerPublicField = 44;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private int outerPrivateField = 10;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private static String outerPrivateStaticField = &quot;123&quot;;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private void outerPrivateMethod() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;outerPrivateMethod&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; @Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void name() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; InnerClass innerClass = new InnerClass();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(innerClass.innerPrivateField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; innerClass.innerPublicMethod();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; innerClass.innerProtectedMethod();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; innerClass.innerDefaultMethod();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; innerClass.innerPrivateMethod();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; StaticNestedClass staticNestedClass = new StaticNestedClass();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(staticNestedClass.staticNestedPrivateField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(StaticNestedClass.staticNestedPrivateStaticField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; staticNestedClass.staticNestedPrivateMethod();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; staticNestedClass.staticNestedPublicMethod();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; //As a member of the OuterClass, a nested class can be declared private, public, protected, or package private</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private class InnerClass {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private int innerPrivateField = 10;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //static declarations in inner classes are not supported</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //private static void innerStaticMethod() {}</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //inner classes have access to other members of the enclosing class, even if they are declared private</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void innerPublicMethod() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(outerPrivateField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outerPrivateMethod();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; void innerDefaultMethod() {}</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private void innerPrivateMethod() {}</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private void innerProtectedMethod() {}</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private static class StaticNestedClass {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private static int staticNestedPrivateStaticField = 44;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private int staticNestedPrivateField = 55;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void staticNestedPublicMethod() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(outerPrivateStaticField);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Static nested classes DO NOT have access to other members of the enclosing class:</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //System.out.println(outerPrivateField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //System.out.println(outerPublicField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private void staticNestedPrivateMethod() {</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public static void staticNestedPublicStaticMethod() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(outerPrivateStaticField);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><h4 class="c29 c26" id="h.mm6gg57kgt6d"><span class="c41">Shadowing</span></h4><p class="c9"><span class="c0">If a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration shadows the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone. The following example, ShadowTest, demonstrates this:</span></p><a id="t.6d12ad659ef977abfb20acb3046c9af87d697abe"></a><a id="t.28"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp;public class ShadowTest {</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public int x = 0;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; class FirstLevel {</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public int x = 1;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; void methodInFirstLevel(int x) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;x = &quot; + x);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;this.x = &quot; + this.x);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public static void main(String... args) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ShadowTest st = new ShadowTest();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ShadowTest.FirstLevel fl = st.new FirstLevel();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; fl.methodInFirstLevel(23);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">The following is the output of this example:</span></p><a id="t.8122b423a8869581c5565434365ad3776fb21e99"></a><a id="t.29"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">x = 23</span></p><p class="c14"><span class="c0">this.x = 1</span></p><p class="c14"><span class="c0">ShadowTest.this.x = 0</span></p></td></tr></table><h1 class="c42 c26" id="h.ctjfqnfyns5h"><span class="c38">Collections</span></h1><p class="c9"><span class="c0">The Collection in Java is a framework that provides an architecture to store and manipulate the group of objects.</span></p><p class="c9"><span class="c0">Java Collections can achieve all the operations that you perform on a data such as searching, sorting, insertion, manipulation, and deletion.</span></p><p class="c9"><span class="c50"><a class="c23" href="https://www.google.com/url?q=https://www.baeldung.com/java-collections&amp;sa=D&amp;source=editors&amp;ust=1657548985872508&amp;usg=AOvVaw3C1tFeOyWh6g0IEJRghSNE">https://www.baeldung.com/java-collections</a></span><span class="c0">&nbsp;</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 289.33px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 289.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c27 c26" id="h.s3mryiq9cwqj"><span class="c13">Collection</span></h2><p class="c9"><span class="c0">This is the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Java platform doesn&rsquo;t provide any direct implementations of this interface.</span></p><p class="c9"><span>The interface has methods to tell you how many elements are in the collection (</span><span class="c11">size, isEmpty</span><span>), to check whether a given object is in the collection (</span><span class="c11">contains</span><span>), to add and remove an element from the collection (</span><span class="c11">add, remove</span><span>), and to provide an iterator over the collection (</span><span class="c11">iterator</span><span class="c0">).</span></p><p class="c9"><span>Collection interface also provides bulk operations methods that work on the entire collection &ndash; </span><span class="c11">containsAll, addAll, removeAll, retainAll, clear</span><span class="c0">.</span></p><p class="c9"><span>The </span><span class="c11">toArray</span><span class="c0">&nbsp;methods are provided as a bridge between collections and older APIs that expect arrays on input.</span></p><h2 class="c27 c26" id="h.uiuam2zbcmjh"><span class="c13">Iterable</span></h2><p class="c9"><span class="c0">An Iterable represents a collection that can be traversed. Implementing the Iterable interface allows an object to make use of the for-each loop. It does that by internally calling the iterator() method on the object. For example, the following code only works as a List interface extends the Collection interface, and the Collection interface extends the Iterable interface.</span></p><ul class="c8 lst-kix_8ian3glbwk9e-0 start"><li class="c9 c25 li-bullet-0"><span>Iterator&lt;T&gt; </span><span class="c11">iterator</span><span class="c0">();</span></li><li class="c9 c25 li-bullet-0"><span>default void </span><span class="c11">forEach</span><span class="c0">(Consumer&lt;? super T&gt; action) {...}</span></li><li class="c9 c25 li-bullet-0"><span>default Spliterator&lt;T&gt; </span><span class="c11">spliterator</span><span class="c0">() {...}</span></li></ul><h2 class="c27 c26" id="h.tbwwtn6lcuo3"><span class="c13">Iterator</span></h2><p class="c9"><span>Iterator interface provides methods to iterate over any Collection. We can get an iterator instance from a Collection using the iterator method. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators allow the caller to remove elements from the underlying collection during the iteration. Iterators in collection classes implement </span><span class="c11">Iterator Design Pattern</span><span class="c0">.</span></p><p class="c9"><span class="c0">The contract for Iterable is that it should produce a new instance of an Iterator every time the iterator() method is called. This is because the Iterator instance maintains the iteration state, and things won&rsquo;t work as if the implementation returns the same Iterator twice.</span></p><ul class="c8 lst-kix_99z3queijxrv-0 start"><li class="c9 c25 li-bullet-0"><span>boolean </span><span class="c11">hasNext</span><span class="c0">();</span></li><li class="c9 c25 li-bullet-0"><span>E </span><span class="c11">next</span><span class="c0">();</span></li><li class="c9 c25 li-bullet-0"><span>default void </span><span class="c11">remove</span><span class="c0">() { throw new UnsupportedOperationException(&quot;remove&quot;); }</span></li><li class="c9 c25 li-bullet-0"><span>default void </span><span class="c11">forEachRemaining</span><span class="c0">(Consumer&lt;? super E&gt; action) {...}</span></li></ul><h3 class="c20" id="h.qilfk793yp2d"><span class="c32">ConcurrentModificationException</span></h3><p class="c9"><span class="c0">When you create an iterator, it starts to count the modifications that were applied on the collection. If the iterator detects that some modifications were made without using its method (or using another iterator on the same collection), it cannot guarantee anymore that it will not pass twice on the same element or skip one, so it throws this exception.</span></p><p class="c9"><span class="c0">How does the iterator track down the structural modifications of the collection? AbstractList ancestor have a modCount member variable which gets incremented every time the structural change is made:</span></p><a id="t.7517c2cc0b6b00d238b3e3b666717c4bfa78c048"></a><a id="t.30"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">private void fastRemove(Object[] es, int i) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; modCount++;</span></p><p class="c14"><span class="c0">...</span></p></td></tr></table><p class="c9"><span class="c0">Every time a new iterator is instantiated, it remembers the current modCount value:</span></p><a id="t.fa5a34b06cd97b4fe29940dc6cebcd634c456127"></a><a id="t.31"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">private class Itr implements Iterator&lt;E&gt; {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int cursor; &nbsp; &nbsp; &nbsp; // index of next element to return</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int lastRet = -1; // index of last element returned; -1 if no such</span></p><p class="c14"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">int expectedModCount = modCount</span><span class="c0">;</span></p><p class="c14"><span class="c0">...</span></p></td></tr></table><p class="c9"><span class="c0">And it throws an exception if it detects a modification:</span></p><a id="t.2fc13044f823e3a59c85c1dde0dbfef47e739663"></a><a id="t.32"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">final void checkForComodification() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (modCount != expectedModCount)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ConcurrentModificationException();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span>If you need to modify the collection you&#39;re iterating through, you should </span><span class="c11">remove items via iterator.remove</span><span>&nbsp;(and with only one iterator), or make a list of items to remove then </span><span class="c11">remove them after you finished iterating</span><span class="c0">.</span></p><h2 class="c27 c26" id="h.80k7vbcq0ov4"><span class="c13">List</span></h2><p class="c9"><span class="c0">An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.</span></p><h3 class="c20" id="h.r7eg3hn4zqg1"><span class="c32">ArrayList</span></h3><p class="c9"><span class="c0">Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list.</span></p><a id="t.1d4dbe46caed5acf0c01c59aeceadc1b247f0400"></a><a id="t.33"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Insert</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Contains</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get by index</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">ArrayList</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(n)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(n)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(n)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td></tr></table><p class="c9"><span class="c0">The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation.</span></p><p class="c9"><span>Each ArrayList instance has a </span><span class="c11">capacity</span><span class="c0">. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.</span></p><h3 class="c20" id="h.jvt3w4ca73nt"><span class="c32">LinkedList</span></h3><p class="c9"><span class="c0">Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).</span></p><p class="c9"><span class="c0">All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</span></p><a id="t.6d34ce28190b502e1787c53880032de80d968022"></a><a id="t.34"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Add first/last</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Insert</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">LinkedList</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(n)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(n)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(n)</span></p></td></tr></table><h4 class="c29 c26" id="h.60gs7qz0lib"><span class="c41">The Problem of Linked-List</span></h4><p class="c9"><span>The RAM-access speed is so slow that if CPU processes data directly on RAM, 99% of CPU speed will become a waste, and we can just make use of 1% of its power. Therefore, they invented CPU cache to solve this problem. The cache memory is very fast and is integrated directly on CPU. Its access speed is near the CPU speed. So now, instead of accessing data directly on RAM, </span><span class="c11">CPU will access data on RAM indirectly through L1 cache</span><span class="c0">&nbsp;(there are usually three levels of caches, and L1 cache is the fastest among them).</span></p><p class="c9"><span class="c0">However, the CPU cache does not solve the problem completely because memory cache size is much smaller than RAM. We still need RAM as our main memory. And the CPU caches will just hold small pieces of data that are most likely to be needed by the CPU in the near future. Sometimes, the data that the CPU needs to access next is not already in L1 cache (nor in L2 or L3 cache), and it must be fetched from RAM, then the CPU will have to wait for several hundred cycles for the data to become available. This is what we call cache miss.</span></p><p class="c9"><span>Therefore, to reduce cache miss, when the CPU wants to access data at address x in RAM, </span><span class="c11">it will not only fetch the data at address x, but also the neighborhood of address x.</span><span>&nbsp;Because we assume &quot;if a particular memory location is referenced at a particular time, then </span><span class="c11">it is likely that nearby memory locations will be referenced in the near future</span><span>&quot; This is what we call locality of reference. So, </span><span class="c11">if the data to be processed by the CPU is placed right next to each other, we can make use of locality of reference and reduce cache miss, which might cause huge performance overhead if it occurs often</span><span class="c0">.</span></p><p class="c9"><span>Unlike array, which is a cache-friendly data structure because its elements are placed right next to each other, elements of linked-list can be placed anywhere in the memory. So </span><span class="c11">when iterating through linked-list, it will cause a lot of cache miss</span><span class="c0">&nbsp;(since we can&#39;t make use of locality of reference), and introduce lots of performance overheads.</span></p><h4 class="c29 c26" id="h.45pfk0zhzxab"><span class="c41">Performance of Array vs Linked-List</span></h4><p class="c9"><span class="c0">When we perform random-insertion or random-deletion on an array, the subsequent elements need to be moved.</span></p><p class="c9"><span>However, when it comes to a list of small elements (list of POD type, or list of pointers), </span><span class="c11">the cost of moving elements around is cheap, much cheaper than the cost of cache misses</span><span class="c0">. Therefore, most of the time, when working with a list of small data types (whatever type of operations it is: from iterating, random-insertion, random deletion to number crunching), the performance of array will be much better than linked-list.</span></p><p class="c9"><span class="c0">But when we need to work with a list of large elements ( &gt; 32 bytes), the cost of moving elements around grows up to be higher than the cost of linked-lists &quot;usual&quot; cache misses. Then the linked list will have better performance than array.</span></p><p class="c9"><span class="c0">In Java, we&#39;re forced to use a list of references that point to an object in the heap, instead of a list of objects, because reference types are placed on the heap by default and we can just make a reference to it. Since reference is just a managed pointer, its size is no more than 8 bytes.</span></p><h2 class="c27 c26" id="h.nrkdkc7oi47p"><span class="c13">Map</span></h2><p class="c9"><span class="c0">An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. If the map previously contained a mapping for the key, the old value is replaced by the specified value.</span></p><p class="c9"><span class="c0">Why Map interface does not extend Collection interface?</span></p><p class="c9"><span class="c0">A good answer to this question is &ldquo;because they are incompatible&ldquo;. Collection has a method add(Object o). Map can not have such method because it need key-value pair. There are other reasons also such as Map supports keySet, valueSet etc. Collection classes does not have such views.</span></p><p class="c9"><span class="c0">Due to such big differences, Collection interface was not used in Map interface, and it was build in separate hierarchy.</span></p><h3 class="c20" id="h.6hje4ynqsh46"><span class="c32">HashMap</span></h3><p class="c9"><span class="c0">Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. </span></p><p class="c9"><span>When we put an object into a HashMap, it uses the key&rsquo;s </span><span class="c11">hash code</span><span class="c0">&nbsp;value to determine if an element is not in the map already. </span></p><p class="c54"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 444.12px; height: 273.50px;"><img alt="" src="images/image14.png" style="width: 444.12px; height: 273.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c0">Each hash code value corresponds to a certain bucket location which can contain various elements, for which the calculated hash value is the same. But two objects with the same hashCode might not be equal. So, objects within the same bucket will be compared using the equals() method.</span></p><a id="t.03d406aab53c4d64ecfa10afe4edbfe07c00e780"></a><a id="t.35"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Put</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">ContainsKey</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">HashMap</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td></tr></table><p class="c9"><span>In the </span><span class="c11">worst case scenario</span><span>, all the items in the map have the same hash code and are therefore stored in the same bucket. In this case, you&#39;ll need to iterate over all of them serially, which would be an </span><span class="c11">O(n)</span><span class="c0">&nbsp;operation.</span></p><p class="c9"><span>Since different keys can be mapped to the same index, there is a chance of collision. If the number of collisions is very high (In this case, you&#39;ll need to iterate over all of the keys serially), the </span><span class="c11">worst case runtime is O(N)</span><span class="c0">, where N is the number of keys. However, we generally assume a good implementation that keeps collisions to a minimum, in which case the lookup time is O(1).</span></p><p class="c9"><span class="c0">A good key object for HashMap fits requirements:</span></p><ul class="c8 lst-kix_px80xspa50tp-0 start"><li class="c9 c25 li-bullet-0"><span>Maintain the </span><span class="c11">hashcode contract</span><span class="c0">&nbsp;(between hashCode() and equals())</span></li><li class="c9 c25 li-bullet-0"><span>Make the key object </span><span class="c31 c11">immutable</span></li><li class="c9 c25 li-bullet-0"><span>Implement hashCode() method so that least number of hash collisions occurs and entries are </span><span class="c11">evenly distributed</span><span class="c0">&nbsp;across all the buckets.</span></li></ul><p class="c9"><span>For example, String is a good HashMap key candidate because it is immutable &rarr; its hash code is </span><span class="c11">computed and cached</span><span class="c0">&nbsp;once hashcode() is called.</span></p><p class="c9"><span>The performance of a HashMap is affected mainly by two parameters &ndash; its </span><span class="c11">Initial Capacity</span><span>(number of buckets) and the </span><span class="c11">Load Factor</span><span class="c0">:</span></p><ul class="c8 lst-kix_g58d2ggy4gc1-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">The load factor describes what is the maximum fill level, above which, a set will need to be resized. </span></li><li class="c9 c25 li-bullet-0"><span class="c0">A low initial capacity reduces space complexity but increases the frequency of rehashing which is an expensive process. On the other hand, a high initial capacity increases the cost of iteration and the initial memory consumption.</span></li></ul><p class="c9"><span class="c0">Some properties of HashMap:</span></p><ul class="c8 lst-kix_g58d2ggy4gc1-0"><li class="c9 c25 li-bullet-0"><span class="c0">Java HashMap allows null key and null values.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">HashMap is not an ordered collection. You can iterate over HashMap entries through keys set but they are not guaranteed to be in the order of their addition to the HashMap.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">HashMap uses it&rsquo;s inner class Node&lt;K,V&gt; for storing map entries.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">HashMap stores entries into multiple singly linked lists, called buckets or bins. Default number of bins is 16 and it&rsquo;s always power of 2.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">HashMap uses hashCode() and equals() methods on keys for get and put operations. So HashMap key object should provide good implementation of these methods. This is the reason immutable classes are better suitable for keys, for example String and Integer.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Java HashMap is not thread safe, for multithreaded environment you should use ConcurrentHashMap class or get synchronized map using Collections.synchronizedMap() method.</span></li></ul><h4 class="c29 c26" id="h.lw8hi88s9ia"><span class="c41">Fixed HashCode issue</span></h4><p class="c9"><span class="c0">You can implement your hashCode() method such that you always return a fixed value, for example like this:</span></p><a id="t.10b7611d0e3eb73da612ebc3c3f11144cd9639df"></a><a id="t.36"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Override</span></p><p class="c14"><span class="c0">public int hashCode() { &nbsp; &nbsp; </span></p><p class="c14"><span class="c0">&nbsp; return 1;</span></p><p class="c14"><span class="c0">} </span></p></td></tr></table><p class="c9"><span>The above method satisfies all the requirements and is considered legal according to the </span><span>hash code</span><span>&nbsp;contract but it would not be very efficient. If this method is used, </span><span class="c11">all objects will be stored in the same bucket</span><span>&nbsp;</span><span>i.e.</span><span class="c0">&nbsp;bucket 1 and when you try to ensure whether the specific object is present in the collection, then it will always have to check the entire content of the collection.</span></p><h4 class="c29 c26" id="h.1wnbyh5zybnv"><span class="c41">Array-as-key issue</span></h4><p class="c9"><span class="c0">In the example below we created two similar-looking arrays. &#39;a&#39; and &#39;b&#39; look equal but their hash codes differ because hash code for an array is derived from the memory address of the object in the heap (not a mandatory rule though). The .equals() by default checks if two Object references refer to the same Object (which is false in our example).</span></p><p class="c9"><span>Behavior for both </span><span class="c11">hashcode and equals</span><span>&nbsp;methods in the array object is </span><span class="c11">not related to the array content</span><span class="c0">. </span></p><a id="t.5b3251efc4ee57fe718d722547dbd0e80e884887"></a><a id="t.37"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">void arrayAsHashMapKeyTest() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; HashMap&lt;Object, Object&gt; objects = new HashMap&lt;&gt;();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int[] a = new int[] {1, 2, 3};</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int[] b = new int[] {1, 2, 3};</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;&#39;a&#39; hashcode: &quot; + a.hashCode());</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;&#39;b&#39; hashcode: &quot; + b.hashCode());</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;a.equals(b) = &quot; + a.equals(b));</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; objects.put(a, new Object());</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; assertTrue(objects.containsKey(a));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; assertFalse(objects.containsKey(b));</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; a[2] = 4;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;&#39;a&#39; hashcode after modifying: &quot; + a.hashCode());</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">Output:</span></p><a id="t.bdeabce39a39ec92100193f40c1737faf502e96d"></a><a id="t.38"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&#39;a&#39; hashcode: 1722021981</span></p><p class="c14"><span class="c0">&#39;b&#39; hashcode: 1019153279</span></p><p class="c14"><span class="c0">a.equals(b) = false</span></p><p class="c14"><span class="c0">&#39;a&#39; hashcode after modifying: 1722021981</span></p></td></tr></table><h3 class="c20" id="h.4v7o4putoqk7"><span class="c32">LinkedHashMap</span></h3><p class="c9"><span class="c0">Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map.</span></p><a id="t.3b1915b90d38f7ea8e799ece35a664846a57f3bf"></a><a id="t.39"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Put</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">ContainsKey</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">LinkedHashMap</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td></tr></table><h3 class="c20" id="h.h4n6965qnfbs"><span class="c32">TreeMap</span></h3><p class="c9"><span>A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a </span><span class="c11">Comparator</span><span class="c0">&nbsp;provided at map creation time, depending on which constructor is used.</span></p><a id="t.2515463b74d54e62ae239eef2c745fe3d766e6f9"></a><a id="t.40"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Add</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">ContainsKey</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">TreeMap</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td></tr></table><p class="c9"><span class="c0">For example we would want to store the collection of strings ordered by string length:</span></p><a id="t.04b0ade9a54cfe189a1173438d08cba6f17ec2cf"></a><a id="t.41"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">TreeMap&lt;String, String&gt; map = new TreeMap&lt;&gt;(Comparator.comparingInt(String::length));</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">map.put(&quot;aaa&quot;, &quot;aaa&quot;);</span></p><p class="c14"><span class="c0">map.put(&quot;b&quot;, &quot;b&quot;);</span></p><p class="c14"><span class="c0">map.put(&quot;cccc&quot;, &quot;cccc&quot;);</span></p><p class="c14"><span class="c0">map.put(&quot;dddd&quot;, &quot;dddd&quot;);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">map.forEach((key,value) -&gt; System.out.println(key + &quot;:&quot; + value));</span></p></td></tr></table><p class="c9"><span class="c0">The output may seem a little bit surprising:</span></p><a id="t.b154dc31bdd155210f7166d458c478a86214442d"></a><a id="t.42"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">b:b</span></p><p class="c14"><span class="c0">aaa:aaa</span></p><p class="c14"><span class="c0">cccc:dddd</span></p></td></tr></table><p class="c9"><span>But how is that possible? The map contract states that while inserting if the map previously contained a mapping for the key, the old </span><span class="c11">value</span><span>&nbsp;is replaced. It says nothing about key replacement, assuming that the comparator respects the </span><span class="c11">(compare(x, y)==0) == (x.equals(y))</span><span class="c0">&nbsp;rule. In the example above however this rule has been violated: &ldquo;dddd&rdquo;.length() == &ldquo;cccc&rdquo;.length(), but !&ldquo;dddd&rdquo;.equals(&ldquo;cccc&rdquo;).</span></p><p class="c22"><span class="c0">JavaDoc for Comparator says:</span></p><p class="c3"><span class="c60 c58 c48">It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. </span></p><p class="c22"><span class="c0">JavaDoc for TreeMap says:</span></p><p class="c3"><span class="c58">Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; </span><span class="c11 c58">it just fails to obey the general contract of the Map interface</span><span class="c58 c48 c60">.</span></p><p class="c9"><span class="c0">Some methods useful for accessing elements in TreeMap:</span></p><ul class="c8 lst-kix_j1holzs3xttc-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">firstKey()/firstEntry() - Returns the first Entry in the TreeMap (according to the TreeMap&#39;s key-sort function). Returns null if the TreeMap is empty.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">lastKey()/lastEntry() - Returns the last Entry in the TreeMap (according to the TreeMap&#39;s key-sort function). Returns null if the TreeMap is empty.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">ceilingKey(K key)/ceilingEntry(K key) - Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists (i.e., the greatest key in the Tree is less than the specified key), returns null.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">floorKey(K key)/floorEntry(K key) - Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the greatest key less than the specified key; if no such entry exists, returns null.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">higherKey(K key)/higherEntry(K key) - Gets the entry for the least key greater than the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists returns null.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">lowerKey(K key)/lowerEntry(K key) - Returns the entry for the greatest key less than the specified key; if no such entry exists (i.e., the least key in the Tree is greater than the specified key), returns null.</span></li></ul><h3 class="c20" id="h.jrtpjynz3t90"><span class="c32">WeakHashMap</span></h3><p class="c9"><span>WeakHashMap is an implementation of the Map interface that stores only </span><span class="c50"><a class="c23" href="#h.bdha5rlh614h">weak references</a></span><span>&nbsp;to its keys. Storing only weak references allows a key-value pair </span><span class="c11">to be garbage collected when its key is no longer referenced outside of the WeakHashMap</span><span class="c0">. This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a look-up of that key in a WeakHashMap at some later time and be surprised that its entry has been removed.</span></p><h2 class="c27 c26" id="h.at74xkebnqyo"><span class="c13">Set</span></h2><p class="c9"><span class="c0">A collection that contains no duplicate elements. </span></p><h3 class="c20" id="h.b4cgsd75mj3w"><span class="c32">HashSet</span></h3><p class="c9"><span class="c0">The most important aspects of this implementation:</span></p><ul class="c8 lst-kix_pflig4lw612i-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">It stores unique elements and permits nulls</span></li><li class="c9 c25 li-bullet-0"><span>It&#39;s backed by a </span><span class="c50"><a class="c23" href="#h.6hje4ynqsh46">HashMap</a></span></li><li class="c9 c25 li-bullet-0"><span class="c0">It doesn&#39;t maintain insertion order</span></li><li class="c9 c25 li-bullet-0"><span class="c0">It&#39;s not thread-safe</span></li></ul><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 587.66px; height: 251.50px;"><img alt="" src="images/image4.png" style="width: 587.66px; height: 251.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><a id="t.79ce279291a0cfaeddd446ed7a8e086b522cba6c"></a><a id="t.43"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Add</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Contains</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">HashSet</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td></tr></table><p class="c9"><span>In the </span><span class="c11">worst case scenario</span><span>, all the items in the set have the same hash code and are therefore stored in the same bucket. In this case, you&#39;ll need to iterate over all of them serially, which would be an </span><span class="c11">O(n)</span><span class="c0">&nbsp;operation.</span></p><p class="c9"><span class="c0">In HashSet, the argument passed in add(Object) method serves as map key. Java internally associates dummy value for each value passed in add(Object) method:</span></p><a id="t.5267f4c307dcb3146d857cda2f79dda03871539e"></a><a id="t.44"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">// Dummy value to associate with an Object in the backing Map</span></p><p class="c14"><span class="c0">private static final Object PRESENT = new Object();</span></p><p class="c14"><span class="c0">...</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">public boolean add(E e) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return map.put(e, PRESENT)==null;</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><h3 class="c20" id="h.f429fs5mtpc7"><span class="c32">LinkedHashSet</span></h3><p class="c9"><span>Hash table and linked list implementation of the Set interface, with predictable iteration order. This implementation differs from HashSet in that </span><span class="c11">it maintains a doubly-linked list</span><span class="c0">&nbsp;running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.)</span></p><a id="t.c3163babd3cd8a531c4a0947b377bb622d947814"></a><a id="t.45"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Add</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Contains</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">LinkedHashSet</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(1)</span></p></td></tr></table><h3 class="c20" id="h.5x2zpaolc6lw"><span class="c32">TreeSet</span></h3><p class="c9"><span>A NavigableSet implementation based on a </span><span class="c50"><a class="c23" href="#h.h4n6965qnfbs">TreeMap</a></span><span class="c0">. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.</span></p><a id="t.b1987c42dea672cb8bf8e03593971ae358b2fe24"></a><a id="t.46"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Complexity</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Add</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Get</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Contains</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">TreeSet</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">O(logN)</span></p></td></tr></table><h2 class="c27 c26" id="h.k2us0n3j21ox"><span class="c13">Queue</span></h2><p class="c9"><span>The </span><span class="c11">Queue</span><span>&nbsp;interface present in the java.util package and extends the Collection interface is used to hold the elements about to be processed in </span><span class="c11">FIFO</span><span class="c0">(First In First Out) order. It is an ordered list of objects with its use limited to insert elements at the end of the list and deleting elements from the start of the list, (i.e.), it follows the FIFO or the First-In-First-Out principle.</span></p><p class="c9"><span class="c0">Being an interface the queue needs a concrete class for the declaration and the most common classes are the PriorityQueue, ArrayBlockingQueue, LinkedList in Java.</span></p><p class="c9"><span class="c11">Characteristics of a Queue</span><span class="c0">: </span></p><ul class="c8 lst-kix_7x9dfnwo95qd-0 start"><li class="c9 c25 li-bullet-0"><span>The Queue is used to insert elements at the end of the queue and removes from the beginning of the queue. </span><span class="c11">It follows FIFO concept</span><span class="c0">.</span></li><li class="c9 c25 li-bullet-0"><span>The Java Queue supports all methods of </span><span class="c11">Collection interface</span><span class="c0">&nbsp;including insertion, deletion etc.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">If any null operation is performed on BlockingQueues, NullPointerException is thrown.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The Queues which are available in java.util package are Unbounded Queues.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The Queues which are available in java.util.concurrent package are the Bounded Queues.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">All Queues except the Deques supports insertion and removal at the tail and head of the queue respectively. The Deques support element insertion and removal at both ends.</span></li></ul><h3 class="c20" id="h.k9t42x89wwp5"><span class="c32">BlockingQueue</span></h3><p class="c9"><span>The Java BlockingQueue interface, java.util.concurrent.BlockingQueue, represents a queue which is </span><span class="c11">thread safe</span><span class="c0">&nbsp;to put elements into, and take elements out of from. In other words, multiple threads can be inserting and taking elements concurrently from a Java BlockingQueue, without any concurrency issues arising. Blocking Queue additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element.</span></p><p class="c9"><span>lockingQueue methods come in four forms, with </span><span class="c11">different ways of handling operations that cannot be satisfied immediately</span><span class="c0">, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table:</span></p><a id="t.676d18df37f3b32c04ca1d4bac1c6c3aa7c0517c"></a><a id="t.47"></a><table class="c18"><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c5"><span class="c0"></span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Throws exception</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Special value</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Blocks</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">Times out</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Insert</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">add(e)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">offer(e)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">put(e)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">offer(e, time, unit)</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Remove</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">remove()</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">poll()</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">take()</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">poll(time, unit)</span></p></td></tr><tr class="c6"><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c31 c11">Examine</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">element()</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">peek()</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">not applicable</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c14"><span class="c0">not applicable</span></p></td></tr></table><p class="c9"><span>A BlockingQueue </span><span class="c11">does not accept null elements</span><span class="c0">. Implementations throw NullPointerException on attempts to add, put or offer a null. A null is used as a sentinel value to indicate failure of poll operations.</span></p><h3 class="c20" id="h.gbgknwblt5mp"><span class="c32">PriorityBlockingQueue</span></h3><p class="c9"><span>An unbounded blocking </span><span class="c11">priority</span><span>&nbsp;queue based on a priority heap. The elements of the priority queue are </span><span class="c11">ordered</span><span>&nbsp;according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used. A priority queue </span><span class="c11">does not permit null elements</span><span class="c0">. A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException).</span></p><h3 class="c20" id="h.xya7355meygr"><span class="c32">SynchronousQueue</span></h3><p class="c9"><span>A blocking queue in which </span><span class="c11">each insert operation must wait for a corresponding remove operation by another thread</span><span>, and vice versa. A synchronous queue does not have any internal capacity, not even a capacity of one. You </span><span class="c11">cannot peek</span><span>&nbsp;at a synchronous queue because an element is only present when you try to remove it; you </span><span class="c11">cannot insert an element (using any method) unless another thread is trying to remove it</span><span>; you </span><span class="c11">cannot iterate</span><span>&nbsp;as there is nothing to iterate. The head of the queue is the element that the first queued inserting thread is trying to add to the queue; if there is no such queued thread then no element is available for removal and poll() will return null. For purposes of other Collection methods (for example contains), a SynchronousQueue acts as an empty collection. </span><span class="c11">This queue does not permit null elements</span><span class="c0">.</span></p><p class="c9"><span>Synchronous queues are well suited for </span><span class="c11">handoff designs</span><span class="c0">, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or task.</span></p><h3 class="c20" id="h.vnabw3hfkex7"><span class="c32">ArrayBlockingQueue</span></h3><p class="c9"><span class="c0">A bounded blocking queue backed by an array. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.</span></p><p class="c9"><span>This is a classic &quot;</span><span class="c11">bounded buffer</span><span>&quot;, in which a fixed-sized array holds elements inserted by producers and extracted by consumers. Once created, the </span><span class="c11">capacity cannot be changed</span><span class="c0">. Attempts to put an element into a full queue will result in the operation blocking; attempts to take an element from an empty queue will similarly block.</span></p><h3 class="c20" id="h.gf5mbif9h4hz"><span class="c32">LinkedBlockingQueue</span></h3><p class="c9"><span>An optionally-bounded blocking queue based on </span><span class="c11">linked nodes</span><span>. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. </span><span class="c11">Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.</span></p><h2 class="c27 c26" id="h.n977wt22ug8m"><span class="c13">Thread-safe collections</span></h2><p class="c9"><span class="c0">If multiple threads access an unsynchronized collection concurrently, and at least one of the threads modifies the collection structurally, it must be synchronized externally.</span></p><h3 class="c20" id="h.t21gm2hqtdn2"><span class="c32">Synchronized collections</span></h3><p class="c9"><span class="c0">Synchronized collections achieve thread-safety through intrinsic locking, and the entire collections are locked. Intrinsic locking is implemented via synchronized blocks within the wrapped collection&#39;s methods.</span></p><p class="c9"><span class="c0">As we might expect, synchronized collections assure data consistency/integrity in multi-threaded environments. However, they might come with a penalty in performance, as only one single thread can access the collection at a time (a.k.a. synchronized access).</span></p><ul class="c8 lst-kix_uox1zzti676w-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Synchronization at Object level.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Every read/write operation needs to acquire lock.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">Locking the entire collection</span><span class="c0">&nbsp;is a performance overhead.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">This essentially gives access to only one thread to the entire map &amp; blocks all the other threads.</span></li></ul><a id="t.61b4b777eaea82a6adaa7c24ba146caf1fa57194"></a><a id="t.48"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Map&lt;Object, Object&gt; syncHashMap = Collections.synchronizedMap(new HashMap&lt;&gt;());</span></p><p class="c14"><span class="c0">Map&lt;Object, Object&gt; syncLinkedMap = Collections.synchronizedMap(new LinkedHashMap&lt;&gt;());</span></p><p class="c14"><span class="c0">SortedMap&lt;Object, Object&gt; syncSortedMap = Collections.synchronizedSortedMap(new TreeMap&lt;&gt;());</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">Set&lt;Object&gt; syncHashSet = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></p><p class="c14"><span class="c0">Set&lt;Object&gt; syncLinkedHashSet = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;());</span></p><p class="c14"><span class="c0">SortedSet&lt;Object&gt; syncSortedSet = Collections.synchronizedSortedSet(new TreeSet&lt;&gt;());</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">List&lt;Object&gt; syncList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></p></td></tr></table><h3 class="c20" id="h.fyflm8vgmw2x"><span class="c32">Concurrent collections</span></h3><p class="c9"><span>Concurrent collections (e.g. ConcurrentHashMap), achieve thread-safety by dividing their data into segments. In a ConcurrentHashMap, for example, different threads can acquire locks on each segment, so multiple threads can access the Map at the same time (a.k.a. concurrent access). On the other hand, Collections.synchronized...() will lock all the data while updating, other threads can only access the data when the lock is released. </span><span class="c11">Concurrent collections are much more performant than synchronized collections</span><span>, due to the inherent advantages of concurrent thread access. </span><span class="c11">If there are many update operations and relative small amount of read operations, you should choose ConcurrentHashMap</span><span class="c0">.</span></p><p class="c9"><span class="c0">Also one other difference is that ConcurrentHashMap will not preserve the order of elements in the Map passed in. It is similar to HashMap when storing data. There is no guarantee that the element order is preserved. For example, if you pass a TreeMap to ConcurrentHashMap, the elements order in the ConcurrentHashMap may not be the same as the order in the TreeMap, but Collections.synchronizedMap() will preserve the order.</span></p><ul class="c8 lst-kix_o9kmpjmc1djl-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">You should use ConcurrentHashMap when you need very high concurrency in your project.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">It is thread safe without synchronizing the whole map.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Reads can happen very fast while write is done with a lock.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">There is no locking at the object level.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The locking is at a much finer granularity at a hashmap bucket level.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">ConcurrentHashMap doesn&rsquo;t throw a ConcurrentModificationException if one thread tries to modify it while another is iterating over it.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">ConcurrentHashMap uses multitude of locks.</span></li></ul><a id="t.77a9747d63b20d851a0fd82c46cb8dfbf8019c31"></a><a id="t.49"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">ConcurrentHashMap&lt;Object, Object&gt; concHashMap = new ConcurrentHashMap&lt;&gt;();</span></p></td></tr></table><p class="c9"><span class="c0">There&#39;s no built in type for ConcurrentHashSet because you can always derive a set from a map. Since there are many types of maps, you use a method to produce a set from a given map (or map class):</span></p><a id="t.b366bc779bac2cf42da85fbbfbabd2505d3720ff"></a><a id="t.50"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Set&lt;Object&gt; concHashSet = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span></p><p class="c14"><span class="c0">//or using Guava (effectively the same):</span></p><p class="c14"><span class="c0">Set&lt;Object&gt; concHashSet2 = Sets.newConcurrentHashSet();</span></p></td></tr></table><h3 class="c20" id="h.oexb0ef8og7o"><span class="c32">CopyOnWriteArray</span></h3><h4 class="c29 c26" id="h.9ho82fbyktpz"><span class="c41">CopyOnWriteArrayList</span></h4><p class="c9"><span>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by </span><span class="c11">making a fresh copy of the underlying array</span><span class="c0">.</span></p><p class="c9"><span>This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don&#39;t want to synchronize traversals, yet need to preclude interference among concurrent threads. The </span><span class="c11">&quot;snapshot&quot; style iterator</span><span>&nbsp;method uses a reference to the state of the array at the point that the iterator was created. </span><span class="c11">This array never changes during the lifetime of the iterator</span><span>, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. </span><span class="c11">The iterator will not reflect additions, removals, or changes to the list since the iterator was created</span><span class="c0">. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException.</span></p><h4 class="c29 c26" id="h.xyxitcdjo4i9"><span class="c41">CopyOnWriteArraySet</span></h4><p class="c9"><span class="c0">A Set that uses an internal CopyOnWriteArrayList for all of its operations. Thus, it shares the same basic properties:</span></p><ul class="c8 lst-kix_ngi8s7ju6o3u-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">It is best suited for applications in which set sizes generally stay small, read-only operations vastly outnumber mutative operations, and you need to prevent interference among threads during traversal.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">It is thread-safe.</span></li><li class="c9 c25 li-bullet-0"><span class="c31 c11">Mutative operations (add, set, remove, etc.) are expensive since they usually entail copying the entire underlying array.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Iterators do not support the mutative remove operation.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Traversal via iterators is fast and cannot encounter interference from other threads. Iterators rely on unchanging snapshots of the array at the time the iterators were constructed.</span></li></ul><h1 class="c42 c26" id="h.cxwxlowjheh2"><span class="c38">Exceptions</span></h1><p class="c9"><span class="c0">An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions.</span></p><p class="c9"><span class="c0">In Java, an exception is an object that wraps an error event that occurred within a method and contains:</span></p><ul class="c8 lst-kix_hh9fkajeox2u-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Information about the error including its type</span></li><li class="c9 c25 li-bullet-0"><span class="c0">The state of the program when the error occurred</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Optionally, other custom information</span></li></ul><p class="c9"><span>Exception objects can be </span><span class="c11">thrown</span><span>&nbsp;and </span><span class="c11">caught</span><span class="c0">.</span></p><p class="c54"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 396.78px; height: 319.86px;"><img alt="" src="images/image3.png" style="width: 396.78px; height: 319.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c27 c26" id="h.ovhvbl77qmok"><span class="c13">Checked vs Unchecked</span></h2><p class="c9"><span class="c0">These are the exceptions that are checked at compile time. If some code within a method throws a checked exception, then the method must either handle the exception or it must specify the exception using throws keyword.</span></p><p class="c9"><span class="c0">Unchecked are the exceptions that are not checked at compile time.</span></p><p class="c9"><span class="c11">JavaDoc recommendation</span><span class="c0">: If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.</span></p><h2 class="c27 c26" id="h.11m92bv6ata"><span class="c13">Try-with-resources</span></h2><p class="c9"><span class="c0">The try-with-resources statement is a try statement that declares one or more resources. A resource is an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource.</span></p><a id="t.cfe261cc481692baaf6ddf99d91bad88dbe48e67"></a><a id="t.51"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">static String readFirstLineFromFile(String path) throws IOException {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; try (BufferedReader br =</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new BufferedReader(new FileReader(path))) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return br.readLine();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><h1 class="c26 c42" id="h.hc7srdu9kewn"><span class="c38">Generics</span></h1><p class="c9"><span class="c0">Generic (parametrized) types are implicitly invariant in Java, meaning that different instantiations of a generic type are not compatible among each other.</span></p><a id="t.1a8ccaad220982e9c015322c0c5bf17ed73a52ee"></a><a id="t.52"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Generic&lt;SuperType&gt; superGeneric;</span></p><p class="c14"><span class="c0">Generic&lt;SubType&gt; subGeneric;</span></p><p class="c14"><span class="c0">subGeneric = (Generic&lt;SubType&gt;)superGeneric; // type error</span></p><p class="c14"><span class="c0">superGeneric = (Generic&lt;SuperType&gt;)subGeneric; // type error</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span class="c0">Java Generics were introduced in JDK 5.0 with the aim of reducing bugs and adding an extra layer of abstraction over types. </span></p><p class="c9"><span class="c0">Java Generic methods and generic classes enable programmers to specify, with a single method declaration, a set of related methods, or with a single class declaration, a set of related types, respectively.</span></p><p class="c9"><span class="c0">Generics also provide compile-time type safety that allows programmers to catch invalid types at compile time.</span></p><p class="c9"><span class="c0">Using Java Generic concept, we might write a generic method for sorting an array of objects, then invoke the generic method with Integer arrays, Double arrays, String arrays and so on, to sort the array elements.</span></p><p class="c9"><span>You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define </span><span class="c11">Generic Methods</span><span class="c0">:</span></p><ul class="c8 lst-kix_jk8gstwbu4x7-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">All generic method declarations have a type parameter section delimited by angle brackets (&lt; and &gt;) that precedes the method&#39;s return type.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name.</span></li><li class="c3 c25 li-bullet-0"><span class="c0">The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic method, which are known as actual type arguments.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A generic method&#39;s body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char).</span></li></ul><p class="c9"><span class="c0">Following example illustrates how we can print an array of different type using a single Generic method:</span></p><a id="t.2b16e433f2666fb1386bd128c898536efa9bbe64"></a><a id="t.53"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void genericsTest() {</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; printAll(new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;});</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; printAll(new Integer[] {1, 2, 3, 4});</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; printAll(new Object[] {new Object(){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public String toString() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &quot;custom object&quot;;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }});</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public &lt;X&gt; void printAll(X[] elements) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (X el : elements) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.printf(&quot;%s&quot;, el);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><h2 class="c9 c26" id="h.dvqax9chic7e"><span class="c13">Bounded Type Parameters</span></h2><p class="c3"><span class="c0">There may be times when you&#39;ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. </span></p><p class="c9"><span class="c0">We can specify that a method accepts a type and all its subclasses (upper bound) or a type all its superclasses (lower bound).</span></p><p class="c9"><span>To declare a bounded type parameter, list the type parameter&#39;s name, followed by the </span><span class="c11">extends</span><span class="c0">&nbsp;keyword, followed by its upper bound.</span></p><a id="t.391c5b53e78da59feeb30e0cd3a9ea1677bd0a2c"></a><a id="t.54"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public &lt;X extends Comparable&lt;X&gt;&gt; X maximum(X x, X y) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (x.compareTo(y) &gt; 0) return x;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; else return y;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><h2 class="c26 c27" id="h.ushqcul1ovn4"><span class="c13">Generic Classes</span></h2><p class="c9"><span class="c0">A generic class declaration looks like a non-generic class declaration, except that the class name is followed by a type parameter section.</span></p><p class="c9"><span class="c0">As with generic methods, the type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as parameterized classes or parameterized types because they accept one or more parameters.</span></p><a id="t.8aaf1dd95a9baa371b78af2ba3beb1e2c88f6b87"></a><a id="t.55"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">class Container&lt;T&gt; {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private T t;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public Container(T t) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.t = t;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public T getT() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return t;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c16 c35"><span class="c0"></span></p><h2 class="c9 c26" id="h.ta1x1b5ed4xn"><span class="c13">Type Erasure</span></h2><p class="c9"><span>Generics were added to Java to ensure type safety and to ensure that generics wouldn&#39;t cause overhead at runtime, </span><span class="c11">the compiler applies a process called type erasure on generics at compile time</span><span class="c0">.</span></p><p class="c9"><span class="c11">Type erasure removes all type parameters and replaces it with their bounds or with Object</span><span class="c0">&nbsp;if the type parameter is unbounded. Thus the bytecode after compilation contains only normal classes, interfaces and methods thus ensuring that no new types are produced. Proper casting is applied as well to the Object type at compile time.</span></p><p class="c9"><span class="c0">This is an example of type erasure:</span></p><a id="t.8395b76335ea90f8a8751abe7b18f39f91ea9a01"></a><a id="t.56"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public &lt;T&gt; List&lt;T&gt; genericMethod(List&lt;T&gt; list) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; return list.stream().collect(Collectors.toList());</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">With type erasure, the unbounded type T is replaced with Object as follows:</span></p><a id="t.398558f21fce188615c955cc4a5aa080fa07d858"></a><a id="t.57"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">// for illustration</span></p><p class="c14"><span class="c0">public List&lt;Object&gt; withErasure(List&lt;Object&gt; list) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; return list.stream().collect(Collectors.toList());</span></p><p class="c14"><span class="c0">}</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">// which in practice results in</span></p><p class="c14"><span class="c0">public List withErasure(List list) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; return list.stream().collect(Collectors.toList());</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">If the type is bounded, then the type will be replaced by the bound at compile time:</span></p><a id="t.9e1a4ceacfff1e0be46e7ece4197d3104797da73"></a><a id="t.58"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public &lt;T extends Building&gt; void genericMethod(T t) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; ...</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">would change after compilation:</span></p><a id="t.7f8f03522f0aacf47f1d9484969b1598ace61c76"></a><a id="t.59"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public void genericMethod(Building t) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; ...</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">Thus, the two method declarations must not occur together in an interface (or abstract class) definition:</span></p><a id="t.e4e5e2980950da4b6582743af47c7159f57e605c"></a><a id="t.60"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">void method(Generic&lt;SuperType&gt; p); </span></p><p class="c14"><span class="c0">void method(Generic&lt;SubType&gt; p);</span></p></td></tr></table><h2 class="c9 c26" id="h.4uxq25wvd5mz"><span class="c13">Wildcards</span></h2><p class="c9"><span class="c0">It is known that Object is the supertype of all Java classes, however, a collection of Object is not the supertype of any collection.</span></p><p class="c9"><span class="c0">For example, a List&lt;Object&gt; is not the supertype of List&lt;String&gt; and assigning a variable of type List&lt;Object&gt; to a variable of type List&lt;String&gt; will cause a compiler error. This is to prevent possible conflicts that can happen if we add heterogeneous types to the same collection.</span></p><p class="c9"><span class="c0">The Same rule applies to any collection of a type and its subtypes. Consider this example:</span></p><a id="t.a43612b840de68784b85b0b7ec5a02c15dffcf69"></a><a id="t.61"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public static void paintAllBuildings(List&lt;Building&gt; buildings) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; buildings.forEach(Building::paint);</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">if we imagine a subtype of Building, for example, a House, we can&#39;t use this method with a list of House, even though House is a subtype of Building. If we need to use this method with type Building and all its subtypes, then the bounded wildcard can do the magic:</span></p><a id="t.8f5ee66687b9b28d52cadd3a5a97106ddf06cb9b"></a><a id="t.62"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public static void paintAllBuildings(List&lt;? extends Building&gt; buildings) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; ...</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">Now, this method will work with type Building and all its subtypes. This is called an upper bounded wildcard where type Building is the upper bound.</span></p><p class="c9"><span class="c0">Wildcards can also be specified with a lower bound, where the unknown type has to be a supertype of the specified type. Lower bounds can be specified using the super keyword followed by the specific type, for example, &lt;? super T&gt; means unknown type that is a superclass of T (= T and all its parents).</span></p><h3 class="c9 c26" id="h.cvuxfjqdmso2"><span class="c32">Wildcard Guidelines </span></h3><p class="c16"><span class="c50"><a class="c23" href="https://www.google.com/url?q=https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html&amp;sa=D&amp;source=editors&amp;ust=1657548985966383&amp;usg=AOvVaw1sdVoQrEzDjqhwEasE9nwB">https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html</a></span><span class="c0">&nbsp;</span></p><ul class="c8 lst-kix_efftnt5a2xc6-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">An &quot;in&quot; variable is defined with an upper bounded wildcard, using the extends keyword.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">An &quot;out&quot; variable is defined with a lower bounded wildcard, using the super keyword.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">In the case where the &quot;in&quot; variable can be accessed using methods defined in the Object class, use an unbounded wildcard.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">In the case where the code needs to access the variable as both an &quot;in&quot; and an &quot;out&quot; variable, do not use a wildcard.</span></li></ul><h2 class="c9 c26" id="h.21ty5dsrzwiy"><span class="c13">QA</span></h2><p class="c9"><span class="c11">Unbound wildcards &lt;?&gt; vs &lt;Object&gt;</span><span class="c0">&nbsp;: The difference is List&lt;?&gt; will take any List with whatever declaration, but List&lt;Object&gt; will only take something that was declared as List&lt;Object&gt;, nothing else.</span></p><p class="c9"><span class="c0">The last quote simply states, that List&lt;?&gt; is a list for which you literally don&#39;t know what type its items are. Because of that, you can not add anything to it other than null.</span></p><p class="c9"><span class="c11">bounded wildcards or bounded type parameter?</span><span class="c0">&nbsp;</span></p><a id="t.ca65e8b0270a6babb22fcf0981ca0ed876ebcc24"></a><a id="t.63"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">instead of creating a method like this:</span></p><p class="c14"><span class="c0">public void drawAll(List&lt;? extends Shape&gt; shapes){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; for (Shape s: shapes) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; s.draw(this);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">This works fine too:</span></p><a id="t.b46b8532612955d348d2694dca0187ec81bd08de"></a><a id="t.64"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public &lt;T extends Shape&gt; void drawAll(List&lt;T&gt; shapes){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; for (Shape s: shapes) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; s.draw(this);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">Which way should I use? Is wildcard useful in this case?</span></p><p class="c9"><span class="c0">It depends on what you need to do. You need to use the bounded type parameter if you wanted to do something like this:</span></p><a id="t.4897c61d22ececc6c9ae02fe5c5fa07e7f1a774d"></a><a id="t.65"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public &lt;T extends Shape&gt; void addIfPretty(List&lt;T&gt; shapes, T shape) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; if (shape.isPretty()) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;shapes.add(shape);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span>Here we have a List&lt;T&gt; shapes and a T shape, therefore we can safely shapes.add(shape). If it was declared List&lt;? extends Shape&gt;, you can NOT safely add to it (</span><span class="c11">because you may have a List&lt;Square&gt; and a Circle</span><span class="c0">).</span></p><p class="c9"><span>So by giving a name to a bounded type parameter, we have the option to use it elsewhere in our generic method. This information is not always required, of course, so if you don&#39;t need to know that much about the type (e.g. your drawAll), then just wildcard is sufficient.</span></p><a id="t.1d96e669cc1cf5aeb086aa9b6f8fcb07d52eab06"></a><a id="t.66"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public &lt;T extends Comparable&lt;T&gt;&gt; T wildcardMethod(List&lt;T&gt; c) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; T max = c.get(0); &nbsp; //we can use the type information</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (T t : c) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (t.compareTo(max) &gt; 0) max = t;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return max;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span class="c0">Using wildcards:</span></p><a id="t.dc73670d82929b3f1b1bdcac2f0bbf4f76063f47"></a><a id="t.67"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public void wildcardMethod2(List&lt;? extends Comparable&lt;?&gt;&gt; in) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //no access to type</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Comparable&lt;?&gt; comparable = in.get(0);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //does not compile</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //comparable.compareTo(in.get(1));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span>Even if you&#39;re not referring to the bounded type parameter again, a </span><span class="c11">bounded type parameter is still required if you have multiple bounds</span><span class="c0">.</span></p><p class="c9"><span class="c0">A wildcard can have only one bound, while a type parameter can have several bounds. A wildcard can have a lower or an upper bound, while there is no such thing as a lower bound for a type parameter.</span></p><p class="c9"><span class="c0">Wildcard bounds and type parameter bounds are often confused, because they are both called bounds and have in part similar syntax.</span></p><a id="t.acb8da7d9f7717929069b27b6de1b21ab2b95b4d"></a><a id="t.68"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; type parameter bound &nbsp; &nbsp; T extends Class &amp; Interface1 &amp; &hellip; &amp; InterfaceN</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; wildcard bound &nbsp;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; upper bound &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;? extends SuperType</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; lower bound &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;? super &nbsp; SubType</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span class="c0">A wildcard can have only one bound, either a lower or an upper bound. A list of wildcard bounds is not permitted. A type parameter, in constrast, can have several bounds, but there is no such thing as a lower bound for a type parameter.</span></p><p class="c9"><span class="c0">Example from Collections utils:</span></p><a id="t.380ae7f30a3bdaeee422b4f8cdd469c8a4d14e3c"></a><a id="t.69"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {</span></p></td></tr></table><p class="c9"><span class="c0">Explanation: Any subclass of T (including T) can be safely casted to any class Object...T (including T).</span></p><p class="c9"><span class="c0">Summary:</span></p><ul class="c8 lst-kix_54rh6a6ewprb-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Do use bounded type parameters/wildcards, they increase flexibility of your API</span></li><li class="c9 c25 li-bullet-0"><span class="c0">If the type requires several parameters, you have no choice but to use bounded type parameter</span></li><li class="c9 c25 li-bullet-0"><span class="c0">if the type requires a lowerbound, you have no choice but to use bounded wildcard</span></li><li class="c9 c25 li-bullet-0"><span class="c0">&quot;Producers&quot; have upperbounds, &quot;consumers&quot; have lowerbounds (PECS)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Do not use wildcard in return types</span></li></ul><p class="c9"><span class="c0">There are many situations where you simply don&#39;t care what type you are referring to. In those cases, you may use ? without cluttering code with unused type parameter declarations.</span></p><p class="c9"><span>By using a wildcard, you&#39;re explicitely saying: I don&#39;t care about the concrete type of the elements of the list, and what I do doesn&#39;t depend on this type. </span><span class="c11">If the method had to return a T, or pass the T to some other generic type, then you would use a typed method</span><span class="c0">.</span></p><p class="c9"><span class="c0">Note that if the ? had the same semantics (&quot;a List of objects of unknown type&quot;) but a different purpose (&quot;the List would consume objects of unknown type&quot;) things would change very, very radically such that it may be inadvisable (or very difficult) to use a wildcard parameter (at least without a helper method to capture the object&#39;s type).</span></p><p class="c9"><span class="c0">The ? states that the generic code does not require any reference to a type. This could be a class where the properties are independent of any type like the length of a collection.</span></p><p class="c9"><span class="c0">Another reason for the ? is that it provides syntax for less ambiguity for the case when the generic code only needs behavior provided by class Object. As pointed out above, the parameter type &lt;T&gt; would work, but the fact that T was defined and then never used could suggest that the developer left out something.</span></p><p class="c9"><span class="c0">So if &lt;T&gt; is dropped because of semantic ambiguity and &lt;?&gt; is not available, then the developer would be tempted to write &lt;Object&gt;. This however does not allow the generic code to be used for any type, just the Object type.</span></p><p class="c9"><span class="c0">So, &lt;?&gt; is more precise. The &lt;?&gt; very clearly self-documents that the type is intentionally not used elsewhere.</span></p><p class="c9"><span class="c0">Type parameter method is more powerful than the wildcard method: You give the parameter a name which you can reference. For example, consider a method that removes the first element of a list and adds it to the back of the list. With generic parameters, we can do the following:</span></p><a id="t.d1a2ce8352917920fdb606670e449b65acd9b742"></a><a id="t.70"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">static &lt;T&gt; boolean rotateOneElement(List&lt;T&gt; l){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; return l.add(l.remove(0));</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">With a wildcard, this is not possible since l.remove(0) would return capture-1-of-?, but l.add would require capture-2-of-?. I.e., the compiler is not able to deduce that the result of remove is the same type that add expects. This is contrary to the first example where the compiler can deduce that both is the same type T. This code would not compile:</span></p><a id="t.79b0c263eaa8d8e11218d832a580aada795f7bdd"></a><a id="t.71"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">static boolean rotateOneElement(List&lt;?&gt; l){</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; return l.add(l.remove(0)); //ERROR!</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">So, what can you do if you want to have a rotateOneElement method with a wildcard, since it is easier to use than the generic solution? The answer is simple: Let the wildcard method call the generic one, then it works:</span></p><a id="t.bfa013b5a46a30dbdfcbe291b0d7f66e202cf12e"></a><a id="t.72"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">private static &lt;T&gt; boolean rotateOneElementImpl(List&lt;T&gt; l){ &nbsp; // Private implementation</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; return l.add(l.remove(0));</span></p><p class="c14"><span class="c0">}</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">static void rotateOneElement(List&lt;?&gt; l){ &nbsp;//Public interface</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp;rotateOneElementImpl(l);</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">The standard library uses this trick in a number of places. One of them is, IIRC, Collections.java</span></p><p class="c9"><span class="c0">When you are declaring a type parameter, and using it only once, it essentially becomes a wildcard parameter. On the other hand, if you use it more than once, the difference becomes significant. e.g.</span></p><a id="t.838ee93de402a677a0651d30858070773e22779b"></a><a id="t.73"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&lt;E&gt; void printObjectsExceptOne(List&lt;E&gt; list, E object) {</span></p></td></tr></table><p class="c9"><span>You might see that this case </span><span class="c11">enforces both types to be the same</span><span class="c0">. </span></p><p class="c9"><span class="c0">As a result, if you are going to use a type parameter only once, it does not even make sense to name it. That is why java architects invented so called wildcard arguments (most probably). </span></p><p class="c9"><span class="c0">Wildcard parameters avoid unnecessary code bloat and make code more readable. If you need two, you have to fall back to regular syntax for type parameters.</span></p><a id="t.7f92b5db88a72f1ef70bb85c51a001a54d04ae51"></a><a id="t.74"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">ArrayList&lt;? extends CharSequence&gt; cs = new ArrayList&lt;&gt;();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //this works as any subclass of CharSequence can be safely upcasted to CharSequence (type producing)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; CharSequence charSequence = cs.get(0);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //below line won&#39;t compile, as &#39;cs&#39; may be of any type other than String (type consuming)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //cs.add(&quot;string&quot;);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ArrayList&lt;? super String&gt; strs = new ArrayList&lt;&gt;();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //this works as String can be safely upcasted to any type Object..String (type consuming)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; strs.add(&quot;234&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Object type available here (without explicit casting) because this list can be of any type between Object..String</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Object s = strs.get(0);</span></p></td></tr></table><h1 class="c42 c26" id="h.b93nh51ozwk"><span class="c38">Functional Programming</span></h1><p class="c9"><span>The biggest advantage of adopting functional programming in any language, including Java, is </span><span class="c11">pure functions and immutable states</span><span class="c0">. If we think in retrospect, most of the programming challenges are rooted in the side-effects and mutable state one way or the other. Simply getting rid of them makes our program easier to read, reason about, test, and maintain.</span></p><p class="c9"><span>A </span><span class="c11">functional interface</span><span class="c0">&nbsp;in Java is an interface that only has one abstract method. By an abstract method is meant only one method which is not implemented. An interface can have multiple methods, e.g. default methods and static methods, both with implementations, but as long as the interface only has one method that is not implemented, the interface is considered a functional interface.</span></p><p class="c9"><span class="c0">Some examples of functional interfaces:</span></p><a id="t.7cad1fdec40a7eeefd762bc8cd71a8de85145581"></a><a id="t.75"></a><table class="c18"><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c16"><span class="c31 c11">Interface name</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c16"><span class="c31 c11">Method</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c16"><span class="c0">Comparable</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c16"><span class="c0">public int compareTo(T o)</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">Predicate</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">boolean test(T t);</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">Function</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">R apply(T t);</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">BiFunction</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">R apply(T t, U u);</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">UnaryOperator</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">same as function but T = R</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">BinaryOperator</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">same as bifunction but T = U = R</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">Consumer</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">void accept(T t);</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">Supplier</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">T get();</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">Runnable</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">public abstract void run();</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">Callable</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c14"><span class="c0">V call() throws Exception;</span></p></td></tr></table><h2 class="c27 c26" id="h.s83jkugrqaeo"><span class="c13">Java Stream API</span></h2><p class="c9"><span>To perform a sequence of operations over the elements of the data source and aggregate their results, we need three parts: the </span><span class="c11">source</span><span>, </span><span class="c11">intermediate operation</span><span>(s) and a </span><span class="c11">terminal operation</span><span class="c0">.</span></p><p class="c9"><span class="c0">We can instantiate a stream, and have an accessible reference to it, as long as only intermediate operations are called. </span></p><h3 class="c20" id="h.fwy95ym89xg2"><span class="c32">Stream creation</span></h3><p class="c3"><span>There are many ways to create a stream instance of different sources. Once created, the instance </span><span class="c11">will not modify its source</span><span class="c0">, therefore allowing the creation of multiple instances from a single source.</span></p><a id="t.4214b976d409164f77a9035a3b0836904eeb5ddc"></a><a id="t.76"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;String&gt; streamEmpty = Stream.empty();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Collection&lt;String&gt; collection = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;String&gt; streamOfCollection = collection.stream();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;String&gt; streamOfArray = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; String[] arr = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;String&gt; streamOfArrayFull = Arrays.stream(arr);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;String&gt; streamBuilder =</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stream.&lt;String&gt;builder().add(&quot;a&quot;).add(&quot;b&quot;).add(&quot;c&quot;).build();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;String&gt; streamGenerated =</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Stream.generate(() -&gt; &quot;element&quot;).limit(10);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Stream&lt;Integer&gt; streamIterated = Stream.iterate(40, n -&gt; n + 2).limit(20);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; IntStream intStream = IntStream.range(1, 3);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; LongStream longStream = LongStream.rangeClosed(1, 3);</span></p></td></tr></table><h3 class="c20" id="h.b5eamwoup21u"><span class="c32">Stream transformation</span></h3><p class="c9"><span class="c0">Intermediate operations return a new modified stream. </span></p><p class="c9"><span class="c11">Intermediate operations are lazy</span><span class="c0">. This means that they will be invoked only if it is necessary for the terminal operation execution.</span></p><p class="c9"><span class="c0">Intermediate operations which reduce the size of the stream should be placed before operations which are applying to each element. So we need to keep methods such as skip(), filter(), and distinct() at the top of our stream pipeline.</span></p><a id="t.c082e55bc82e0aacd10b160810cc1777ce147a66"></a><a id="t.77"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">String result = IntStream.range(1, 100) //stream creation</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filter(i -&gt; i % 2 == 0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//intermediate operation</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .mapToObj(String::valueOf) &nbsp; //intermediate operation</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.joining()); &nbsp;//stream termination</span></p></td></tr></table><p class="c9"><span class="c0">Here is the list of intermediate operations:</span></p><ul class="c8 lst-kix_3n4k5copjjhj-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">map(..)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">flatMap(..)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">sorted(..)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">peek(..)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">limit(..)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">skip(..)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">distinct()</span></li><li class="c9 c25 li-bullet-0"><span class="c0">filter(..)</span></li></ul><p class="c9"><span class="c0">Another example:</span></p><a id="t.f59e48649de784d309235d6f8159cf54e4298df8"></a><a id="t.78"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Set&lt;Integer&gt; books = users.stream()</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filter(User::isActive)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filter(u -&gt; u.getAge() &gt; 25)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(User::getBooks)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filter(CollectionUtils::isNotEmpty)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .flatMap(Collection::stream)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(User.Book::getId)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.toUnmodifiableSet());</span></p></td></tr></table><h3 class="c20" id="h.gu692zq8hjm7"><span class="c32">Stream termination</span></h3><p class="c9"><span>A stream by itself is worthless; the user is interested in the result of the terminal operation, which can be a </span><span class="c11">value</span><span>&nbsp;of some type or an </span><span class="c11">action</span><span class="c0">&nbsp;applied to every element of the stream. </span></p><p class="c9"><span class="c0">We can only use one terminal operation per stream: executing a terminal operation makes a stream inaccessible. An attempt to reuse the same reference after calling the terminal operation will trigger the IllegalStateException.</span></p><p class="c9"><span>The API has many terminal operations which aggregate a stream to a type or to a primitive: </span><span class="c11">count</span><span>(), </span><span class="c11">max</span><span>(), </span><span class="c11">min</span><span>(), and </span><span class="c11">sum</span><span>(). However, these operations work according to the predefined implementation. So what if a developer needs to customize a Stream&#39;s reduction mechanism? There are two methods which allow us to do this, the </span><span class="c11">reduce</span><span>() and the </span><span class="c11">collect</span><span class="c0">() methods.</span></p><h4 class="c29 c26" id="h.egfp6wya7dua"><span class="c41">Reduce</span></h4><p class="c9"><span class="c0">Applying some scalar function to reduce all the elements to a single result.</span></p><a id="t.e46e05873ce8b06f19512aa37bcd92b3e71613c4"></a><a id="t.79"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&lt;U&gt; U reduce(U identity, </span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BiFunction&lt;U, ? super T, U&gt; accumulator,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BinaryOperator&lt;U&gt; combiner);</span></p></td></tr></table><ul class="c8 lst-kix_dam61a68r3zx-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">identity - initial value for the combiner function</span></li><li class="c9 c25 li-bullet-0"><span class="c0">accumulator - function for incorporating an additional element into a result</span></li><li class="c14 c25 li-bullet-0"><span class="c0">combiner - function for combining values produced by a combiner</span></li></ul><p class="c9"><span class="c0">Given a stream of type Integer, reduce its elements to a result of type String: </span></p><a id="t.407316eea91e7f87bc8f68c7ab20bc87715458ca"></a><a id="t.80"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">String joined = IntStream.range(0, 100).boxed()</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .reduce(&quot;&quot;, (res, i) -&gt; res + i.toString(), (a, b) -&gt; a + b);</span></p></td></tr></table><h4 class="c29 c26" id="h.600yvu61w6uh"><span class="c41">Collect</span></h4><p class="c9"><span class="c0">Stream.collect(...) performs a mutable reduction operation on the elements of this stream:</span></p><a id="t.6013bc52edf846e6fa25d32a8a0096096601f1ae"></a><a id="t.81"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BiConsumer&lt;R, ? super T&gt; accumulator,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BiConsumer&lt;R, R&gt; combiner);</span></p></td></tr></table><ul class="c8 lst-kix_g47nti3zp8ay-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">supplier - function for combining values produced by a combiner</span></li><li class="c9 c25 li-bullet-0"><span class="c0">accumulator - function for adding additional element to collection</span></li><li class="c9 c25 li-bullet-0"><span class="c0">combiner - function for merging intermediate collections</span></li></ul><p class="c9"><span class="c0">Example of collecting stream elements to ArrayList:</span></p><a id="t.7a4f3072d1cc51dc300dd75fa653a04c0f299c13"></a><a id="t.82"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">List&lt;Integer&gt; collected = IntStream.range(0, 100).boxed().collect(</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; () -&gt; new ArrayList&lt;&gt;(), </span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (list, el) -&gt; list.add(el), </span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (list1, list2) -&gt; list1.addAll(list2));</span></p></td></tr></table><p class="c9"><span class="c0">Some predefined collectors: </span></p><ul class="c8 lst-kix_doe34qsvg1pd-0 start"><li class="c9 c25 li-bullet-0"><span class="c11">toList()</span><span class="c0">&nbsp;:There are no guarantees on the type, mutability, serializability, or thread-safety of the List returned.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">toMap</span><span>&nbsp;(keyMapper, valueMapper, </span><span class="c43">mergeFunction</span><span>, </span><span class="c43">mapSupplier</span><span>): If mapSupplier is not specified, the HashMap is used. For parallel stream pipelines, the combiner function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the Map in encounter order, using </span><span class="c11">toConcurrentMap</span><span class="c0">(Function, Function) may offer better parallel performance.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">toSet</span><span class="c0">&nbsp;(There are no guarantees on the type, mutability, serializability, or thread-safety of the Set returned)</span></li><li class="c9 c25 li-bullet-0"><span class="c11">toCollection</span><span class="c0">&nbsp;(Supplier&lt;C&gt; collectionFactory): Returns a Collector that accumulates the input elements into a new Collection, in encounter order.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">mapping</span><span>&nbsp;(Function&lt;? super T, ? extends U&gt; </span><span class="c11">mapper</span><span>, Collector&lt;? super U, A, R&gt; </span><span class="c11">downstream</span><span class="c0">) - adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation:</span></li></ul><p class="c16 c47"><span class="c0">return new CollectorImpl&lt;&gt;(downstream.supplier(),</span></p><p class="c16 c47"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(r, t) -&gt; downstreamAccumulator.accept(r, </span><span class="c11">mapper.apply</span><span class="c0">(t)),</span></p><p class="c16 c47"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;downstream.combiner(), downstream.finisher(),</span></p><p class="c16 c47"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;downstream.characteristics());</span></p><p class="c16 c47"><span class="c0">Example:</span></p><a id="t.85bd878ffbdde2890a9bdb9f7f7a8d845e770515"></a><a id="t.83"></a><table class="c40"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Map&lt;Integer, Set&lt;String&gt;&gt; collectedToStringSet = IntStream.range(0, 100).boxed().collect(</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Collectors.groupingBy(i -&gt; i % 3, </span></p><p class="c14"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Collectors.</span><span class="c11">mapping</span><span class="c0">(String::valueOf, Collectors.toSet())));</span></p></td></tr></table><ul class="c8 lst-kix_doe34qsvg1pd-0"><li class="c9 c25 li-bullet-0"><span class="c11">partitioningBy</span><span>&nbsp;(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream): Returns a Collector which partitions the input elements according to a Predicate, reduces the values in each partition according to another Collector, and organizes them into a </span><span class="c11">Map&lt;Boolean, D&gt;</span><span class="c0">&nbsp;whose values are the result of the downstream reduction.</span></li></ul><p class="c22 c47"><span class="c0">Example:</span></p><a id="t.d984058afc039b8add3fcaf6883bda145db0ceff"></a><a id="t.84"></a><table class="c40"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span>Map&lt;</span><span class="c11">Boolean</span><span class="c0">, List&lt;Integer&gt;&gt; collect = IntStream.range(0, 100)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .boxed()</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0));</span></p></td></tr></table><ul class="c8 lst-kix_doe34qsvg1pd-0"><li class="c9 c25 li-bullet-0"><span class="c11">groupingBy</span><span class="c0">&nbsp;(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream): Returns a Collector implementing a cascaded &quot;group by&quot; operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.</span></li></ul><ul class="c8 lst-kix_doe34qsvg1pd-1 start"><li class="c9 c37 li-bullet-0"><span class="c0">&lt;T&gt; &ndash; the type of the input elements</span></li><li class="c9 c37 li-bullet-0"><span class="c0">&lt;K&gt; &ndash; the type of the keys</span></li><li class="c9 c37 li-bullet-0"><span class="c0">&lt;D&gt; &ndash; the result type of the downstream reduction</span></li><li class="c9 c37 li-bullet-0"><span class="c0">&lt;A&gt; &ndash; the intermediate accumulation type of the downstream collector</span></li><li class="c9 c37 li-bullet-0"><span class="c0">&lt;M&gt; &ndash; the type of the resulting Map</span></li></ul><p class="c9"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example:</span></p><a id="t.5c8ddeb3dcdec7321ced850a81ccedde7fb754ab"></a><a id="t.85"></a><table class="c56"><tr class="c6"><td class="c15" colspan="1" rowspan="1"><p class="c14"><span>Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(</span><span class="c11">groupingBy</span><span class="c0">(</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person::getCity,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeMap::new,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping(Person::getLastName, toSet())));</span></p></td></tr></table><ul class="c8 lst-kix_9a8vxc4ia7ct-0 start"><li class="c9 c25 li-bullet-0"><span class="c11">joining</span><span class="c0">&nbsp;(CharSequence delimiter, CharSequence prefix, CharSequence suffix) - returns a Collector that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</span></li></ul><a id="t.ac810e1ac9a9ba8bcf9b3cc0630234ab7a79d84c"></a><a id="t.86"></a><table class="c40"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.joining(&quot;,&quot; ,&quot;prefix&quot;,&quot;suffix&quot;));</span></p><p class="c14"><span class="c0">//prefixA,B,Csuffix</span></p></td></tr></table><p class="c9"><span class="c0">There are following collectors producing unmodifiable collections (by simply wrapping the resulting collection in ImmutableCollections implementation (List.of(..),Set.of(..),Map.of(..)) :</span></p><ul class="c8 lst-kix_lozxriuee1k8-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">toUnmodifiableList()</span></li><li class="c9 c25 li-bullet-0"><span class="c0">toUnmodifiableSet()</span></li><li class="c9 c25 li-bullet-0"><span>toUnmodifiableMap(keyMapper, valueMapper, </span><span class="c43">mergeFunction</span><span class="c0">)</span></li></ul><h3 class="c20" id="h.t4nyk1nq6l15"><span class="c32">Parallel Stream</span></h3><p class="c16"><span>Under the hood, Stream API automatically uses the </span><span class="c11">ForkJoin</span><span>&nbsp;framework to execute operations in parallel. By default, the </span><span class="c11">common thread pool</span><span class="c0">&nbsp;will be used and there is no way (at least for now) to assign some custom thread pool to it. This can be overcome by using a custom set of parallel collectors.</span></p><p class="c16 c35"><span class="c0"></span></p><p class="c16"><span class="c0">When using streams in parallel mode, avoid blocking operations. It is also best to use parallel mode when tasks need a similar amount of time to execute. If one task lasts much longer than the other, it can slow down the complete app&rsquo;s workflow.</span></p><p class="c16 c35"><span class="c0"></span></p><a id="t.bc0282ae792ccfecddfbf1b23cf8f71d9b9b1b6c"></a><a id="t.87"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Stream&lt;Product&gt; streamOfCollection = productList.parallelStream();</span></p><p class="c14"><span class="c0">boolean isParallel = streamOfCollection.isParallel();</span></p><p class="c14"><span class="c0">boolean bigPrice = streamOfCollection</span></p><p class="c14"><span class="c0">&nbsp; .map(product -&gt; product.getPrice() * 12)</span></p><p class="c14"><span class="c0">&nbsp; .anyMatch(price -&gt; price &gt; 200);</span></p></td></tr></table><h2 class="c27 c26" id="h.9mdff64vwe4t"><span class="c13">Optional</span></h2><p class="c9"><span class="c0">Java SE 8 introduces a new class called java.util.Optional&lt;T&gt; that is inspired from the ideas of Haskell and Scala. The purpose of the class is to provide a type-level solution for representing optional values instead of null references.</span></p><p class="c9"><span class="c0">Some examples of using Optional:</span></p><a id="t.3268828ad1dc255906276dc998bcee93832dab74"></a><a id="t.88"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Optional&lt;String&gt; notNullOptional = Optional.of(&quot;im not null&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Assertions.assertTrue(notNullOptional.isPresent());</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Optional&lt;Object&gt; nullPassedOptional = Optional.ofNullable(null);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Assertions.assertTrue(nullPassedOptional.isEmpty());</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Optional&lt;Object&gt; emptyOptional = Optional.empty();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Assertions.assertTrue(nullPassedOptional.isEmpty());</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; notNullOptional.map(s -&gt; s.substring(0, 2))</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ifPresent(System.out::println);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Object orElse = emptyOptional.orElse(&quot;default&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Object orElseGet = emptyOptional.orElseGet(this::loadFromSomewhere);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; String value = notNullOptional</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filter(s -&gt; s.contains(&quot;im&quot;))</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(s -&gt; s.substring(0, 5))</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .orElseThrow(() -&gt; new RuntimeException(&quot;value with &#39;im&#39; is not present!&quot;));</span></p></td></tr></table><h1 class="c42 c26" id="h.jwfw7nhe0unf"><span class="c38">Concurrency</span></h1><h2 class="c27 c26" id="h.5xmrelmixc5n"><span class="c13">Java Memory Model</span></h2><p class="c9"><span class="c0">The Java memory model used internally in the JVM divides memory between thread stacks and the heap.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 297.00px; height: 223.89px;"><img alt="" src="images/image8.png" style="width: 297.00px; height: 223.89px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span>Each thread running in the Java virtual machine has its own thread stack. </span><span class="c11">The thread stack contains information about what methods the thread has called to reach the current point of execution</span><span>. I will refer to this as the &quot;</span><span class="c11">call stack</span><span class="c0">&quot;. As the thread executes its code, the call stack changes.</span></p><p class="c9"><span>The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it&#39;s own thread stack. Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code, the two threads will still create the local variables of that code in each their own thread stack. Thus, </span><span class="c11">each thread has its own version of each local variable</span><span class="c0">.</span></p><p class="c9"><span class="c0">All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads. One thread may pass a copy of a primitive variable to another thread, but it cannot share the primitive local variable itself.</span></p><p class="c9"><span class="c0">The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 296.50px; height: 246.00px;"><img alt="" src="images/image1.png" style="width: 296.50px; height: 246.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span>An </span><span class="c11">object&#39;s member variables are stored on the heap along with the object itself</span><span class="c0">. That is true both when the member variable is of a primitive type, and if it is a reference to an object. </span></p><p class="c9"><span class="c0">Static class variables are also stored on the heap along with the class definition.</span></p><p class="c9"><span class="c0">Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object&#39;s member variables. If two threads call a method on the same object at the same time, they will both have access to the object&#39;s member variables, but each thread will have its own copy of the local variables.</span></p><h2 class="c9 c26" id="h.njcvtdhf83ie"><span class="c13">Hardware Memory Architecture</span></h2><p class="c9"><span class="c0">Each CPU contains a set of registers which are essentially in-CPU memory. The CPU can perform operations much faster on these registers than it can perform on variables in main memory. That is because the CPU can access these registers much faster than it can access main memory.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 312.31px; height: 267.96px;"><img alt="" src="images/image6.png" style="width: 312.31px; height: 267.96px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span>Each CPU may also have a </span><span>CPU cache memory layer</span><span>. In fact, most modern CPUs have a cache memory layer of some size. The </span><span class="c11">CPU can access its cache memory much faster than main memory</span><span class="c0">, but typically not as fast as it can access its internal registers. So, the CPU cache memory is somewhere in between the speed of the internal registers and main memory. Some CPUs may have multiple cache layers (Level 1 and Level 2), but this is not so important to know to understand how the Java memory model interacts with memory. What matters is to know that CPUs can have a cache memory layer of some sort.</span></p><p class="c9"><span>Typically, when a CPU needs to access main memory it will </span><span class="c11">read part of main memory into its CPU cache</span><span>. It may even </span><span>read part of the cache into its internal registers</span><span>&nbsp;and then perform operations on it. When the CPU needs to write the result back to main memory it will </span><span>flush the value from its internal register to the cache memory, and at some point</span><span class="c11">&nbsp;flush the value back to main memory</span><span class="c0">.</span></p><p class="c9"><span>The values stored in the cache memory is typically flushed back to main memory when the CPU needs to store something else in the cache memory. The CPU cache can have data written to part of its memory at a time, and flush part of its memory at a time. </span><span class="c11">It does not have to read / write the full cache each time it is updated</span><span>. Typically the cache is updated in smaller memory blocks called &quot;</span><span>cache lines</span><span class="c0">&quot;. One or more cache lines may be read into the cache memory, and one or more cache lines may be flushed back to main memory again.</span></p><p class="c9"><span class="c0">The hardware memory architecture does not distinguish between thread stacks and heap. On the hardware, both the thread stack and the heap are located in main memory. Parts of the thread stacks and heap may sometimes be present in CPU caches and in internal CPU registers.</span></p><p class="c54"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 411.50px; height: 176.36px;"><img alt="" src="images/image12.png" style="width: 411.50px; height: 176.36px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c0">When objects and variables can be stored in various different memory areas in the computer, certain problems may occur. The two main problems are:</span></p><ul class="c8 lst-kix_3a3vs7gz3k6b-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">Visibility of thread updates (writes) to shared variables (solution = volatile/synchronized guarantees)</span></li><li class="c9 c25 li-bullet-0"><span class="c0">Race conditions when reading, checking and writing shared variables (solution = atomicity by means of synchronized/locks/CAS)</span></li></ul><p class="c9"><span class="c50"><a class="c23" href="https://www.google.com/url?q=http://tutorials.jenkov.com/java-concurrency/java-memory-model.html&amp;sa=D&amp;source=editors&amp;ust=1657548986013324&amp;usg=AOvVaw0Opi7wAFw7sD6x7baRH8zG">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></span><span class="c0">&nbsp;</span></p><h2 class="c27 c26" id="h.oz8vuysludyk"><span class="c13">Thread</span></h2><p class="c9"><span>A </span><span class="c11">thread</span><span class="c0">&nbsp;is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</span></p><p class="c9"><span class="c0">Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.</span></p><p class="c9"><span>When a Java Virtual Machine starts up, there is usually a </span><span class="c11">single non-daemon thread</span><span class="c0">&nbsp;(which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</span></p><ul class="c8 lst-kix_yqe02awvv2ik-0 start"><li class="c9 c25 li-bullet-0"><span>The </span><span class="c11">exit method of class Runtime has been called</span><span class="c0">&nbsp;and the security manager has permitted the exit operation to take place.</span></li><li class="c9 c25 li-bullet-0"><span class="c11">All threads that are not daemon threads have died</span><span class="c0">, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.</span></li></ul><p class="c9"><span class="c0">There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started. The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started.</span></p><p class="c9"><span class="c0">Every thread has a name for identification purposes. More than one thread may have the same name. If a name is not specified when a thread is created, a new name is generated for it.</span></p><h2 class="c27 c26" id="h.a1w5auc8ftlr"><span class="c13">Visibility and Happens-Before</span></h2><p class="c9"><span class="c50"><a class="c23" href="https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html%23jls-17.4.5&amp;sa=D&amp;source=editors&amp;ust=1657548986014870&amp;usg=AOvVaw2oxrQAnZ6IW5OeX96Iv1Gy">https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5</a></span><span class="c0">&nbsp;</span></p><p class="c9"><span class="c0">Instruction reordering poses some challenges in a multithreaded, multi CPU system.</span></p><p class="c9"><span class="c0">Example:</span></p><a id="t.9cf661440b614e3e8beb97e8aff080bf1a750bc8"></a><a id="t.89"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public class FrameExchanger &nbsp;{</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private long framesStoredCount = 0:</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private long framesTakenCount &nbsp;= 0;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span>&nbsp; &nbsp; private </span><span class="c11">volatile</span><span class="c0">&nbsp;boolean hasNewFrame = false;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; private Frame frame = null;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; // called by Frame producing thread</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public void storeFrame(Frame frame) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.frame = frame;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.framesStoredCount++;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.hasNewFrame = true;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; // called by Frame drawing thread</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public Frame takeFrame() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while( !hasNewFrame) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //busy wait until new frame arrives</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Frame newFrame = this.frame;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.framesTakenCount++;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.hasNewFrame = false;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return newFrame;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c0">Now, when the hasNewFrame variable is set to true, the frame and frameStoredCount will also be synchronized to main memory. Additionally, every time the drawing thread reads the hasNewFrame variable in the while-loop inside the takeFrame() method, the frame and framesStoredCount will also be refreshed from main memory. Even framesTakenCount will get updated from main memory at this point.</span></p><p class="c9"><span class="c0">Imagine if the Java VM reordered the instructions inside the storeFrame() method, like this:</span></p><a id="t.a8865fc833db754446894405e67ee3e23977293c"></a><a id="t.90"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; &nbsp; // called by Frame producing thread</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; public void storeFrame(Frame frame) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.hasNewFrame = true;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.framesStoredCount++;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.frame = frame;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span class="c0">Now the framesStoredCount and frame fields will get synchronized to main memory when the first instruction is executed (because hasNewFrame is volatile) - which is before they have their new values assigned to them!</span></p><p class="c9"><span class="c0">This means, that the drawing thread executing the takeFrame() method may exit the while-loop before the new value is assigned to the frame variable. Even if a new value had been assigned to the frame variable by the producing thread, there would not be any guarantee that this value would have been synchronized to main memory so it is visible for the drawing thread!</span></p><p class="c9"><span class="c0">As you can see, the reordering of the instructions inside storeFrame() method may make the application malfunction. This is where the volatile write happens before guarantee comes in - to put restrictions on what kind of instruction reordering is allowed around writes to volatile variables.</span></p><p class="c9"><span>Very good explanation of the problem: </span><span class="c50"><a class="c23" href="https://www.google.com/url?q=http://tutorials.jenkov.com/java-concurrency/java-happens-before-guarantee.html&amp;sa=D&amp;source=editors&amp;ust=1657548986025817&amp;usg=AOvVaw21HM3GQWGrB7vU0t7N8_cn">http://tutorials.jenkov.com/java-concurrency/java-happens-before-guarantee.html</a></span><span class="c0">&nbsp;</span></p><h3 class="c20" id="h.adwlb39dxsyn"><span class="c32">volatile keyword</span></h3><p class="c9"><span class="c31 c11">Java Volatile Happens Before Guarantee</span></p><p class="c9"><span class="c0">A write to a non-volatile or volatile variable that happens before a write to a volatile variable is guaranteed to happen before the write to that volatile variable.</span></p><p class="c9"><span class="c0">A read of a volatile variable will happen before any subsequent reads of volatile and non-volatile variables.</span></p><p class="c9"><span class="c31 c11">Java volatile Visibility Guarantee</span></p><p class="c9"><span class="c0">The Java volatile keyword provides some visibility guarantees for when writes to, and reads of, volatile variables result in synchronization of the variable&#39;s value to and from main memory. This synchronization to and from main memory is what makes the value visible to other threads. Hence the term visibility guarantee.</span></p><p class="c9"><span class="c0">When you write to a Java volatile variable the value is guaranteed to be written directly to main memory. Additionally, all variables visible to the thread writing to the volatile variable will also get synchronized to main memory.</span></p><a id="t.0fb33f90a72eaf9404d8738442335d672c1a1f29"></a><a id="t.91"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">this.nonVolatileVarA = 34;</span></p><p class="c14"><span class="c0">this.nonVolatileVarB = new String(&quot;Text&quot;);</span></p><p class="c14"><span class="c0">this.volatileVarC &nbsp; &nbsp;= 300;</span></p></td></tr></table><p class="c9"><span class="c0">When the third instruction in the example above writes to the volatile variable volatileVarC, the values of the two non-volatile variables will also be synchronized to main memory - because these variables are visible to the thread when writing to the volatile variable.</span></p><p class="c9"><span class="c0">When you read the value of a Java volatile the value is guaranteed to be read directly from memory. Furthermore, all the variables visible to the thread reading the volatile variable will also have their values refreshed from main memory.</span></p><a id="t.182bc4f4ae5ff4151be52442ba2ad72810f684a7"></a><a id="t.92"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">c = other.volatileVarC;</span></p><p class="c14"><span class="c0">b = other.nonVolatileB;</span></p><p class="c14"><span class="c0">a = other.nonVolatileA;</span></p></td></tr></table><p class="c9"><span class="c0">Notice that the first instruction is a read of a volatile variable (other.volatileVarC). When other.volatileVarC is read in from main memory, the other.nonVolatileB and other.nonVolatileA are also read in from main memory.</span></p><p class="c9"><span class="c0">Example of the visibility problem:</span></p><a id="t.aa58b6e28dba0d43df09edb81d571165573e0112"></a><a id="t.93"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void visibilityTest() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; MySharedObject mySharedObject = new MySharedObject();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; new Thread(() -&gt; mySharedObject.waitForFlag()).start();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; sleepUninterruptibly(1, TimeUnit.SECONDS);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; mySharedObject.flag = true;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; sleepUninterruptibly(10, TimeUnit.SECONDS);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; class MySharedObject {</span></p><p class="c14"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11">volatile</span><span class="c0">&nbsp;boolean flag = false;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void waitForFlag() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (!flag) {}</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;flag update has been read by another thread&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span class="c0">Having the flag variable not declared as volatile, the &ldquo;flag update has been read by another thread&rdquo; message is never going to appear.</span></p><p class="c9"><span class="c0">Another visibility problem. Consider the problem below. What value is assigned to y?</span></p><a id="t.1db8ea374dc673facfef6ad8793cd7c20444f814"></a><a id="t.94"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">static int x = 0;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">public static void main(String[] args) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; x = 1;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; Thread t = new Thread() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void run() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int y = x;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; };</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; };</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; t.start();</span></p><p class="c14"><span class="c0">}</span></p></td></tr></table><p class="c9"><span class="c11">Complex explanation</span><span class="c0">: When a statement invokes Thread.start(), every statement that has a happens-before relationship with that statement also has a happens-before relationship with every statement executed by the new thread. The effects of the code that led up to the creation of the new thread are visible to the new thread.</span></p><p class="c9"><span class="c0">When a thread terminates and causes a Thread.join() in another thread to return, then all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join. The effects of the code in the thread are now visible to the thread that performed the join.</span></p><p class="c9"><span class="c11">Simple explanation</span><span>: The main thread has changed field x. Java memory model does not guarantee that this change will be visible to other threads if they are not synchronized with the main thread. But thread t will see this change because the main thread called t.start() and JLS guarantees that calling t.start() makes the change to x visible in t.run() so y is guaranteed to be assigned 1. In other words, </span><span class="c11">the newly started thread is guaranteed to see the changes made by the thread that started it</span><span class="c0">, NOT the ones made by other threads.</span></p><h3 class="c20" id="h.36iwa5cip18o"><span class="c32">synchronized keyword</span></h3><p class="c9"><span class="c0">Java synchronized blocks provide visibility guarantees that are similar to those of Java volatile variables. </span></p><p class="c9"><span class="c0">When a thread enters a synchronized block, all variables visible to the thread are refreshed from main memory.</span></p><p class="c9"><span class="c0">When a thread exits a synchronized block, all variables visible to the thread are written back to main memory.</span></p><h2 class="c27 c26" id="h.atjff4edv7ql"><span class="c13">Race Condition</span></h2><p class="c9"><span class="c0">A race condition is a concurrency problem that may occur inside a critical section. A critical section is a section of code that is executed by multiple threads and where the sequence of execution for the threads makes a difference in the result of the concurrent execution of the critical section.</span></p><p class="c9"><span>When the result of multiple threads executing a critical section may differ depending on the sequence in which the threads execute, the critical section is said to contain a race condition. The term race condition stems from the metaphor that the threads are racing through the critical section, and that the </span><span class="c11">result of that race impacts the result of executing the critical section</span><span class="c0">.</span></p><p class="c9"><span class="c0">Race conditions can occur when two or more threads read and write the same variable according to one of these two patterns:</span></p><ul class="c8 lst-kix_je8f38j0gr98-0 start"><li class="c7 li-bullet-0"><span class="c0">Read-modify-write</span></li><li class="c7 li-bullet-0"><span class="c0">Check-then-act</span></li></ul><p class="c16 c35"><span class="c0"></span></p><p class="c16"><span class="c0">Here is the read-modify-write problem:</span></p><a id="t.7960b684bab32c5b1974f09e7eb1e24286d2dbea"></a><a id="t.95"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void atomicityProblemTest() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; MySharedObject mySharedObject = new MySharedObject();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Thread thread = new Thread(mySharedObject);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; thread.start();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; 1000; i++) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mySharedObject.doReadWriteOnSharedResource();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Uninterruptibles.joinUninterruptibly(thread);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;Result: &quot; + mySharedObject.cnt);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; class MySharedObject implements Runnable {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int cnt = 0;</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; void doReadWriteOnSharedResource() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; @Override</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void run() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; 1000; i++) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doReadWriteOnSharedResource();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c5"><span class="c0"></span></p></td></tr></table><p class="c9"><span>Explanation: Increment (i++) is probably not atomic in Java because atomicity is a special requirement which is not present in the majority of the uses. That requirement has a significant overhead: </span><span class="c11">there is a large cost in making an increment operation atomic</span><span class="c0">; it involves synchronization at both the software and hardware levels that need not be present in an ordinary increment.</span></p><p class="c9"><span class="c0">Here is the solution based on synchronized block:</span></p><a id="t.a5d599641fbadec9c1418475438640411e5971e4"></a><a id="t.96"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; synchronized void doReadWriteOnSharedResource() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p></td></tr></table><p class="c22"><span>This problem can also be solved using Compare-And-Swap instruments as well as using Lock objects.</span></p><h2 class="c9 c26" id="h.w99adfk8pgp"><span class="c13">Compare-And-Swap</span></h2><p class="c16"><span>The compare-and-swap (CAS) instruction is an uninterruptible instruction that reads a memory location, compares the read value with an expected value, and stores a new value in the memory location when the read value matches the expected value. Otherwise, nothing is done.</span></p><p class="c22"><span class="c0">AtomicInteger:</span></p><a id="t.ffd740c5630bb7881ac95f6a3e2c529e01cf9484"></a><a id="t.97"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; AtomicInteger cnt = new AtomicInteger(0);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; void doReadWriteOnSharedResource() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt.incrementAndGet();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p></td></tr></table><p class="c22"><span>Java 5 offers this support via java.util.concurrent.atomic: a toolkit of classes used for lock-free, thread-safe programming on single variables: AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference. It also offers array versions of integer, long integer, and reference (AtomicIntegerArray, AtomicLongArray, and AtomicReferenceArray), markable and stamped reference classes for atomically updating a pair of values (AtomicMarkableReference and AtomicStampedReference), and more.</span></p><h2 class="c9 c26" id="h.o1oios646utc"><span class="c13">Locks</span></h2><p class="c9"><span>A </span><span>lock</span><span>&nbsp;is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides </span><span class="c11">exclusive access to a shared resource</span><span>: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, </span><span class="c11">some locks may allow concurrent access to a shared resource</span><span class="c0">, such as the read lock of a ReadWriteLock.</span></p><p class="c9"><span class="c31 c11">All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in Chapter 17 of The Java&trade; Language Specification:</span></p><ul class="c8 lst-kix_i3c8vb9n7x7o-0 start"><li class="c9 c25 li-bullet-0"><span class="c0">A successful lock operation has the same memory synchronization effects as a successful Lock action.</span></li><li class="c9 c25 li-bullet-0"><span class="c0">A successful unlock operation has the same memory synchronization effects as a successful Unlock action.</span></li></ul><p class="c9"><span class="c11">ReentrantLock</span><span>&nbsp;- A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities.</span></p><p class="c22"><span class="c0">Example of using ReentrantLock:</span></p><a id="t.67726e9d48ecb8ce1c3cef1192946e40f5c1bce6"></a><a id="t.98"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int cnt = 0;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Lock lock = new ReentrantLock();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; void doReadWriteOnSharedResource() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.lock();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } finally {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.unlock();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span>Note: All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification, Third Edition (17.4 Memory Model) </span><span class="c50"><a class="c23" href="https://www.google.com/url?q=https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/locks/Lock.html&amp;sa=D&amp;source=editors&amp;ust=1657548986052521&amp;usg=AOvVaw2izJ4IcEEv5p12vEThD-k1">https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/locks/Lock.html</a></span><span>&nbsp;(that&#39;s why we don&rsquo;t need a </span><span class="c11">volatile</span><span class="c0">&nbsp;keyword for cnt variable)</span></p><p class="c9"><span class="c0">To boost performance, ReentrantLock&#39;s synchronization is managed by a subclass of the abstract java.util.concurrent.locks.AbstractQueuedSynchronizer class. In turn, this class leverages the undocumented sun.misc.Unsafe class and its compareAndSwapInt() CAS method.</span></p><p class="c3"><span>A </span><span class="c11">ReadWriteLock</span><span class="c0">&nbsp;maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive.</span></p><p class="c3"><span class="c0">All ReadWriteLock implementations must guarantee that the memory synchronization effects of writeLock operations (as specified in the Lock interface) also hold with respect to the associated readLock. That is, a thread successfully acquiring the read lock will see all updates made upon previous release of the write lock.</span></p><p class="c3"><span class="c0">A read-write lock allows for a greater level of concurrency in accessing shared data than that permitted by a mutual exclusion lock. It exploits the fact that while only a single thread at a time (a writer thread) can modify the shared data, in many cases any number of threads can concurrently read the data (hence reader threads). In theory, the increase in concurrency permitted by the use of a read-write lock will lead to performance improvements over the use of a mutual exclusion lock. In practice this increase in concurrency will only be fully realized on a multi-processor, and then only if the access patterns for the shared data are suitable.</span></p><h2 class="c27 c26" id="h.stdk67qt8a3"><span class="c13">Executors</span></h2><p class="c9"><span class="c11">Executor</span><span class="c0">&nbsp;interface: An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. </span></p><a id="t.31a750a956393081396c668b371ffba8b8820358"></a><a id="t.99"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">void execute(Runnable command);</span></p></td></tr></table><p class="c9"><span class="c0">An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new RunnableTask()).start() for each of a set of tasks, you might use:</span></p><a id="t.7933c2fd99defd3c17a09f74ef55714e12796a08"></a><a id="t.100"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Executor executor = anExecutor();</span></p><p class="c14"><span class="c0">executor.execute(new RunnableTask1());</span></p><p class="c14"><span class="c0">executor.execute(new RunnableTask2());</span></p><p class="c14"><span class="c0">...</span></p></td></tr></table><p class="c9"><span class="c0">However, the Executor interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller&#39;s thread:</span></p><a id="t.d56acc5feff5dc1365ffb98ef0f7619275e42f1e"></a><a id="t.101"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp;class DirectExecutor implements Executor {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;public void execute(Runnable r) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp;r.run();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;}</span></p><p class="c14"><span class="c0">&nbsp;}</span></p></td></tr></table><p class="c9"><span class="c11">ExecutorService</span><span class="c0">: An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.</span></p><p class="c9"><span>An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The </span><span class="c11">shutdown</span><span>&nbsp;method will allow previously submitted tasks to execute before terminating, while the </span><span class="c11">shutdownNow</span><span class="c0">&nbsp;method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted.</span></p><p class="c9"><span class="c0">Method submit extends base method Executor.execute(Runnable) by creating and returning a Future that can be used to cancel execution and/or wait for completion.</span></p><p class="c9"><span class="c11">ThreadPoolExecutor</span><span class="c0">: An ExecutorService that executes each submitted task using one of possibly several pooled threads, normally configured using Executors factory methods.</span></p><p class="c9"><span class="c0">Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks. Each ThreadPoolExecutor also maintains some basic statistics, such as the number of completed tasks.</span></p><p class="c9"><span class="c0">ThreadPoolExecutor can be instantiated using constructor:</span></p><a id="t.d97746f3582b6e40c9ae3fbd17131855e7a1da89"></a><a id="t.102"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">public ThreadPoolExecutor(int corePoolSize,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int maximumPoolSize,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long keepAliveTime,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeUnit unit,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockingQueue&lt;Runnable&gt; workQueue,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThreadFactory threadFactory,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RejectedExecutionHandler handler) {</span></p></td></tr></table><p class="c9"><span>The pool consists of a fixed number of core threads that are kept inside all the time, and some excessive threads that may be spawned and then terminated when they are not needed anymore. The </span><span class="c11">corePoolSize</span><span>&nbsp;parameter is the number of core threads that will be instantiated and kept in the pool. When a new task comes in, if all core threads are busy and the internal queue is full, then the pool is allowed to grow up to </span><span class="c11">maximumPoolSize</span><span class="c0">.</span></p><p class="c9"><span>The </span><span class="c11">keepAliveTime</span><span class="c0">&nbsp;parameter is the interval of time for which the excessive threads (instantiated in excess of the corePoolSize) are allowed to exist in the idle state. By default, the ThreadPoolExecutor only considers non-core threads for removal. In order to apply the same removal policy to core threads, we can use the allowCoreThreadTimeOut(true) method.</span></p><p class="c9"><span class="c0">Let&rsquo;s create a thread pool executor with corePoolSize=maximumPoolSize=4, no keepAlive time, simple ArrayBlockingQueue and blocking RejectedExecutionHandler:</span></p><a id="t.238888ce0041cf4637fe8d8052e3602cfc7f9bc5"></a><a id="t.103"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">&nbsp;@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void executorTest() {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ThreadPoolExecutor executor1 = new ThreadPoolExecutor(4, 4, 0, TimeUnit.SECONDS,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new ArrayBlockingQueue&lt;&gt;(1000),</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thread::new,</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (task, executor) -&gt; Uninterruptibles.putUninterruptibly(executor.getQueue(), task));</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><p class="c9"><span class="c0">Most typical configurations are predefined in the Executors static methods:</span></p><a id="t.f960aa4fdd85b8fe0484334aafe2a370fdf50deb"></a><a id="t.104"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">@Test</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; void predefinedExecutorsTest() {</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ExecutorService fixedThreadPoolExecutor = Executors.newFixedThreadPool(8);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Handled by fixedThreadPoolExecutor&quot;));</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ExecutorService cachedThreadPoolExecutor = Executors.newCachedThreadPool();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Handled by cachedThreadPoolExecutor&quot;));</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(4);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; scheduledExecutorService.scheduleAtFixedRate(() -&gt; System.out.println(&quot;Scheduled task&quot;),</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0, 1, TimeUnit.SECONDS);</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; CompletableFuture.runAsync(() -&gt; System.out.println(&quot;Handled by a singleThreadExecutor&quot;));</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Uninterruptibles.sleepUninterruptibly(10, TimeUnit.SECONDS);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(&quot;Shutting down...&quot;);</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; fixedThreadPoolExecutor.shutdown();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cachedThreadPoolExecutor.shutdown();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; scheduledExecutorService.shutdown();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; singleThreadExecutor.shutdown();</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp; }</span></p></td></tr></table><h2 class="c27 c26" id="h.3kbxf86646s2"><span class="c13">Coordination of threads</span></h2><h3 class="c20" id="h.1un2r3csngz3"><span class="c32">CountDownLatch</span></h3><p class="c9"><span>Essentially, by using a </span><span class="c11">CountDownLatch</span><span class="c0">&nbsp;we can cause a thread to block until other threads have completed a given task.</span></p><p class="c9"><span class="c0">Simply put, a CountDownLatch has a counter field, which you can decrement as we require. We can then use it to block a calling thread until it&#39;s been counted down to zero.</span></p><p class="c9"><span>If we were doing some parallel processing, we could instantiate the CountDownLatch with the same value for the counter as a number of threads we want to work across. Then, we could just call </span><span class="c11">countdown</span><span>() after each thread finishes, guaranteeing that a dependent thread calling </span><span class="c11">await</span><span class="c0">() will block until the worker threads are finished.</span></p><h3 class="c9 c26" id="h.alacdu7r3m4j"><span class="c32">Phaser</span></h3><p class="c9"><span>The </span><span class="c11">Phaser</span><span>&nbsp;is a reusable synchronization barrier. It </span><span>allows us to build logic in which threads need to wait on the </span><span>barrier</span><span class="c0">&nbsp;before going to the next step of execution.</span></p><p class="c9"><span class="c0">We can coordinate multiple phases of execution, reusing a Phaser instance for each program phase. Each phase can have a different number of threads waiting for advancing to another phase. We&#39;ll have a look at an example of using phases later on.</span></p><p class="c9"><span>To participate in the coordination, the thread needs to </span><span class="c11">register</span><span class="c0">() itself with the Phaser instance.</span></p><p class="c9"><span>The thread signals that it arrived at the barrier by calling the </span><span class="c11">arriveAndAwaitAdvance</span><span class="c0">(), which is a blocking method. When the number of arrived parties is equal to the number of registered parties, the execution of the program will continue, and the phase number will increase. We can get the current phase number by calling the getPhase() method.</span></p><p class="c9"><span>When the thread finishes its job, we should call the </span><span class="c11">arriveAndDeregister</span><span class="c0">() method to signal that the current thread should no longer be accounted for in this particular phase.</span></p><p class="c9"><span class="c0">A Phaser may be used instead of a CountDownLatch to control a one-shot action serving a variable number of parties. The typical idiom is for the method setting this up to first register, then start all the actions, then deregister, as in: </span></p><a id="t.99b790e6e8f1ee44d6d77b4088df2b0dbaf8000c"></a><a id="t.105"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">void runTasks(List&lt;Runnable&gt; tasks) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;Phaser startingGate = new Phaser(1); // &quot;1&quot; to register self</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;// create and start threads</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;for (Runnable task : tasks) {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp;startingGate.register();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp;new Thread(() -&gt; {</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;startingGate.arriveAndAwaitAdvance();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;task.run();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp; &nbsp;}).start();</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;}</span></p><p class="c5"><span class="c0"></span></p><p class="c14"><span class="c0">&nbsp; &nbsp;// deregister self to allow threads to proceed</span></p><p class="c14"><span class="c0">&nbsp; &nbsp;startingGate.arriveAndDeregister();</span></p><p class="c14"><span class="c0">&nbsp;}</span></p></td></tr></table><p class="c16 c35"><span class="c0"></span></p><h2 class="c27 c26" id="h.8bkgkhaiiwbg"><span class="c13">ThreadLocal</span></h2><p class="c3"><span class="c0">The TheadLocal construct allows us to store data that will be accessible only by a specific thread.</span></p><p class="c3"><span class="c50"><a class="c23" href="https://www.google.com/url?q=https://github.com/ivanwolkow/developer-book-demo/tree/master/src/test/java/com/example/demo/java/concurrency/threadlocal&amp;sa=D&amp;source=editors&amp;ust=1657548986070764&amp;usg=AOvVaw1FMXqnnD8MwE3DxZDu97UI">https://github.com/ivanwolkow/developer-book-demo/tree/master/src/test/java/com/example/demo/java/concurrency/threadlocal</a></span><span class="c0">&nbsp;</span></p><p class="c3"><span class="c0">Joshua Bloch:</span></p><p class="c3"><span class="c28">Thread-local variables are often used to prevent sharing in designs based on mutable Singletons or global variables. For example, a single-threaded application might maintain a global database connection that is initialized at startup to avoid having to pass a Connection to every method. Since JDBC connections may not be thread-safe, a multithreaded application that uses a global connection without additional coordination is not thread-safe either. By using a ThreadLocal to store the JDBC connection, as in ConnectionHolder in Listing 3.10, each thread will have its own connection.</span></p><p class="c3"><span class="c28">ThreadLocal is widely used in implementing application frameworks. For example, J2EE containers associate a transaction context with an executing thread for the duration of an EJB call. This is easily implemented using a static Thread-Local holding the transaction context: when framework code needs to determine what transaction is currently running, it fetches the transaction context from this ThreadLocal. This is convenient in that it reduces the need to pass execution context information into every method, but couples any code that uses this mechanism to the framework.</span></p><p class="c3"><span class="c61">It is easy to abuse ThreadLocal by treating its thread confinement property as a license to use global variables or as a means of creating &ldquo;hidden&rdquo; method arguments. Like global variables, thread-local variables can detract from reusability and introduce hidden couplings among classes, and should therefore be used with care.</span></p><p class="c16"><span>Example of usage: </span><span class="c31 c11">SecurityContextHolder</span></p><a id="t.86e7749a4bfb3898f3cd260e6392b58bf5642b85"></a><a id="t.106"></a><table class="c18"><tr class="c6"><td class="c4" colspan="1" rowspan="1"><p class="c14"><span class="c0">Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span></p></td></tr></table><p class="c9"><span class="c0">By default the SecurityContextHolder uses a ThreadLocal to store these details, which means that the security context is always available to methods in the same thread of execution, even if the security context is not explicitly passed around as an argument to those methods. Using a ThreadLocal in this way is quite safe if care is taken to clear the thread after the present principal&#39;s request is processed. Of course, Spring Security takes care of this for you automatically so there is no need to worry about it.</span></p><p class="c3"><span>Some applications aren&#39;t entirely suitable for using a ThreadLocal, because of the specific way they work with threads. (...) Other applications might want to have threads spawned by the secure thread also assume the same security identity. This is achieved by using SecurityContextHolder.</span><span class="c11">MODE_INHERITABLETHREADLOCAL</span></p><h1 class="c9 c26" id="h.2pev7b12kbbd"><span class="c38">Changelog. What&rsquo;s new</span></h1><ul class="c8 lst-kix_1ls56psqdc4w-0 start"><li class="c7 li-bullet-0"><span class="c0">Java 8</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-1 start"><li class="c3 c37 li-bullet-0"><span class="c0">Java Stream API, Optional</span></li><li class="c3 c37 li-bullet-0"><span class="c0">lambda expressions</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Interfaces can have static and default methods that, despite being declared in an interface, have a defined behavior. This allows the addition of methods to interfaces without breaking existing implementations</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Annotation on Java types</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Method reference (shorter and more readable alternative for a lambda expression which only calls an existing method). Static method - User::isRealUser, instance method - user::isLegalName</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Date and time API (Local, Zoned)</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-0"><li class="c7 li-bullet-0"><span class="c0">Java 9</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-1 start"><li class="c3 c37 li-bullet-0"><span class="c0">Modularization of the JDK under Project Jigsaw. </span></li></ul><p class="c3 c51"><span class="c0">&#8203;&#8203;One of the main motivations here is to provide modular JVM, which can run on devices with a lot less available memory. The JVM could run with only those modules and APIs which are required by the application. </span></p><p class="c3 c51"><span class="c0">The modules are going to be described in a file called module-info.java located in the top of java code hierarchy.</span></p><ul class="c8 lst-kix_1ls56psqdc4w-1"><li class="c3 c37 li-bullet-0"><span class="c0">Interfaces can have private methods (which can be used to split lengthy default methods)</span></li><li class="c3 c37 li-bullet-0"><span class="c0">JShell REPL (Read-Eval-Print Loop) command-line interface for the Java language</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Ahead-of-time compilation provided by GraalVM.</span></li><li class="c3 c37 li-bullet-0"><span class="c0">New HTTP Client</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Publish-Subscribe Framework - The class java.util.concurrent.Flow provides interfaces that support the Reactive Streams publish-subscribe framework</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Unified JVM Logging. This feature introduces a common logging system for all components of the JVM. It provides the infrastructure to do the logging, but it does not add the actual logging calls from all JVM components. It also does not add logging to Java code in the JDK.</span></li><li class="c3 c37 li-bullet-0"><span class="c0">The logging framework defines a set of tags &ndash; for example, gc, compiler, threads, etc. We can use the command line parameter -Xlog to turn on logging during startup.</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Let&#39;s log messages tagged with &lsquo;gc&#39; tag using &lsquo;debug&#39; level to a file called &lsquo;gc.txt&#39; with no decorations: java -Xlog:gc=debug:file=gc.txt:none &hellip;</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Optional to Stream - java.util.Optional.stream()</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-0"><li class="c7 li-bullet-0"><span class="c0">Java 10</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-1 start"><li class="c3 c37 li-bullet-0"><span class="c0">Local Variable Type Inference (var keyword)</span></li><li class="c3 c37 li-bullet-0"><span class="c0">java.util.List, java.util.Map and java.util.Set each got a new static method copyOf(Collection).</span></li><li class="c3 c37 li-bullet-0"><span class="c0">java.util.stream.Collectors get additional methods to collect a Stream into unmodifiable List, Map or Set</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Optional*.orElseThrow</span></li><li class="c3 c37 li-bullet-0"><span>Starting with Java 10, Oracle has moved to the </span><span class="c11">time-based release </span><span class="c0">of Java. This has following implications:</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-2 start"><li class="c16 c53 li-bullet-0"><span class="c0">A new Java release every six months. </span></li><li class="c16 c53 li-bullet-0"><span class="c0">Support for the feature release will last only for six months, i.e., until next feature release</span></li><li class="c16 c53 li-bullet-0"><span class="c0">Long-term support release will be marked as LTS. Support for such release will be for three years</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-0"><li class="c7 li-bullet-0"><span class="c0">Java 11 (LTS)</span></li></ul><ul class="c8 lst-kix_1ls56psqdc4w-1 start"><li class="c3 c37 li-bullet-0"><span class="c0">New methods in the String class: isBlank, lines, strip, stripLeading, stripTrailing, and repeat.</span></li><li class="c3 c37 li-bullet-0"><span class="c0">new readString and writeString static methods in the Files class</span></li><li class="c3 c37 li-bullet-0"><span>Local-Variable Syntax for Lambda: .map((@Nonnull </span><span class="c11">var</span><span>&nbsp;x) -&gt; x.toUpperCase()). We can make use of this feature to </span><span class="c11">apply modifiers to our local variables</span><span class="c0">, like defining a type annotation</span></li><li class="c3 c37 li-bullet-0"><span class="c0">Running Java Files - we don&#39;t need to compile the Java source files with javac explicitly anymore: java HelloWorld.java</span></li><li class="c3 c37 li-bullet-0"><span class="c0">No-Op Garbage Collector (Epsilon) - it allocates memory but does not actually collect any garbage. Thus, Epsilon is applicable for simulating out of memory errors.</span></li><li class="c3 c37 li-bullet-0"><span class="c48">Java Flight Recorder (JFR) is now open-source in OpenJDK</span></li></ul></body></html>